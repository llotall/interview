**Аспектно-ориентированное**

Аспектно-ориентированное програмирование базируется на изучении того сколько и каких компонент или частей требуется для взаимодействия с системой. Основным для АОП является взаимодействие этих элементов.

**Интерфейсно-ориентированное**

Интерфейсно-ориентированное программирование это подход основанный на программировании по контракту. Ни одна часть интерфейса не зависит от того как реализована другая, вся коммуникация между ними описана в контракте. Веб-сервисы на основе WSDL наиболее известный пример этого подхода.

**Объектно-ориентированное** 

Объектно-ориентированное программирование основывается на понятиях абстракции, инкапсуляции, полиморфизма и наследования. Классы реализуют эти концепции для построения объектов, контролирующих или реализующих систему.

* Абстракция позволяет уменьшить связывание между компонентами пердоставляя дополнительный слой между ними, для того чтоб один объект не зависил от того, как другой реализуюет свои бизнес-правила. (Интерфейсы, слои) Отличная штука, если вы хотите изолировать части системы так, чтоб их изменение или замена не стали проблеммой для работы системы в целом.
* Инкапсуляция позволяет работать абстракции пряча детали реализации класса от вызывающих его. (Публичные и приватные поля)
* Наследование позволяет базовым (родительским) классам содержать общую функциональность и передавать ее всем своим классам-потомкам.
* Полиморфизм позволяет реализовывать одноименные публичные методы, позволяя различным классам выполнять различные действия при одном и том же вызове. То есть объекты классов Square и Circle могут отображаться(реализовывать метод render) поразному несмотря не то, что они оба подклассы Shape, метод render определен в Shape. (Overriding)

 ---

**Что такое CLR? Что такое IL? Что такое CLS?**

* CLR ("Common Language Runtime", "общеязыковая исполняющая среда") - это компонент .NET Framework, основной задачей которого является управление интерпретацией и исполнением кода IL. CLR отвечает за изоляцию памяти приложений, проверку типов, безопасность кода, преобразование IL в машинный код.
* IL (Intermediate Language) - код, содержащий набор инструкций, не зависящих от платформы. Иными словами, после компиляции исходного кода он преобразуется не в код для какой-то определенной платформы, а в промежуточный код на языке IL.
* CLS ("Common Language Specification", общеязыковая спецификация) - это набор правил, следуя которым разработчики достигают бесконфликтной работы во всех языках .NET.

**Какая наименьшая исполнимая единица в .NET?**

сборка

---
# **Память**

**Что такое managed code?**

Управляемый код (managed code) - это код, работающий в среде CLR. Содержит метаданные, в которых находится информация для среды выполнения - о типах, членах и ссылках, используемых в коде.

**Что такое managed и unmanaged resources в .NET?**

Managed ресурсы – это ресурсы для очистки которых используется Garbage collector.

Unmanaged ресурсы – ресурсы которые не очищаются сборщиком мусора и их нужно явно очищать после выполнения кода, который их использовал, например: работа с файлом, работа с бд и тд.

Ситуации, когда мы работаем с неуправляемыми ресурсами:
* Работа с файловыми операциями на низком уровне
* Сетевые операции и сокеты
* Базы данных и соединения
* Вызов функций из неуправляемых библиотек с использованием платформозависимого вызова (P/Invoke)
* Работа с графическими ресурсами
* Работа с COM-объектами

Интероперабельность — это способность различных систем и компонентов взаимодействовать и обмениваться информацией. В контексте программного обеспечения и систем, интероперабельность позволяет компонентам, написанным на разных языках программирования и работающим на разных платформах, корректно взаимодействовать друг с другом.

**В чем различие между Value Type и Reference Type?**

Value Type находятся в стеке, а Reference Type в куче.

## Garbage Collector - start

Статьи:
* https://habr.com/ru/companies/clrium/articles/464169
* https://learn.microsoft.com/ru-ru/dotnet/standard/garbage-collection/large-object-heap


## Фазы сборки мусора

- **Маркировка (mark phase)**:
  Во время этого этапа CLR должна найти все живые объекты. Собирая мусор в эфемерных поколениях, сборщик должен получить у среды исполнения информацию о том, какие объекты в этих поколениях по-прежнему используются программой.

- **Чистка (sweep phase)**:
  На этом этапе моделируется сжатие, чтобы определить его эффективность. Если результат оказывается продуктивным, сборщик начинает фактическое сжатие. В противном случае он просто производит уборку.

- **Сжатие (compact phase)**:
  Если сборщик выполняет сжатие, это приводит к перемещению объектов, и необходимо обновить ссылки на эти объекты. Во время этапа перемещения сборщик должен найти все ссылки, указывающие на объекты в тех поколениях, где проводится сборка мусора. При сжатии объекты будут скопированы по новым адресам, определенным во время этапа планирования.

## Описание работы

Сборщик делит объекты на две категории: маленькие (< 85 000 байт) и большие (>= 85 000 байт). Разделение по размеру происходит, поскольку сжатие больших объектов требует много ресурсов.

После сборки объектов в поколении **N**, оставшиеся объекты маркируются как принадлежащие поколению **N+1**. Этот процесс называется продвижением объектов по поколениям. Существуют исключения, когда необходимо перевести объект в поколение ниже или не продвигать его вообще.

Сборка поколения означает сборку объектов в этом поколении, а также во всех его более молодых поколениях. Сборка мусора поколения 2 также называется полной сборкой мусора.

Пользовательский код может размещать объекты только в поколении **0 (маленькие объекты)** или в куче больших объектов **(большие объекты)**. Только GC может "выделить" объекты в поколении 1 (путем поощрения выживших из поколения 0) и поколения 2 (путем поощрения выживших из поколения 1).

## Этапы сборки мусора

- **Этап маркировки**:
  CLR должна найти все живые объекты. Сборщик должен получить информацию о том, какие объекты в этих поколениях по-прежнему используются программой.

- **Этап планирования**:
  Моделируется сжатие, чтобы определить его эффективность. Если результат продуктивный, сборщик начинает сжатие. В противном случае он просто производит уборку.

- **Этап перемещения**:
  Если сборщик выполняет сжатие, это приводит к перемещению объектов и обновлению ссылок на них.

- **Этап сжатия**:
  Объекты копируются по новым адресам, определенным на этапе планирования.

## Память и сегменты

- **Сегменты**:
  Управляемая куча состоит из набора сегментов – непрерывных блоков памяти, переданных сборщику мусора ОС. Сегменты делятся на мелкие и большие участки для размещения маленьких и больших объектов.

- **Память по времени жизни**:
  Память делится, исходя из времени жизни её элементов. Сегмент кучи заполняется от младших адресов к старшим. 

## Поколения

- **Маленькие объекты**:
  Поколения gen0, gen1.

- **Большие объекты**:
  Одно поколение – gen2.

## Дополнительные вопросы и ответы

**Когда объект удаляется сборщиком мусора?**

Объект удаляется сборщиком мусора, когда на него не остается ссылок.

**Зачем нужен метод DisposeAsync() который добавили в C# 8?**

DisposeAsync позволяет выполнять ресурсоемкую операцию удаления, не блокируя основной поток приложения графического пользовательского интерфейса в течение длительного времени.

**В чем различие между Finalize и Dispose?**

Dispose обеспечивает **явный** контроль над ресурсами, используемыми объектом, а Finalize **неявный**, используемый сборщиком мусора.

**Dispose(), Finalize() – что это за методы, как используются в .NET?**

Используются для освобождения ресурсов. Применяя метод Dispose, вы должны обеспечить неявную очистку методом Finalize. Если программисту не удалось вызвать метод Dispose, использование метода Finalize предотвращает постоянную утечку ресурсов.

### Пример кода

```csharp
public class ResourceHandler : IDisposable
{
    // Управляемый ресурс
    private FileStream managedResource;

    // Неуправляемый ресурс
    private IntPtr unmanagedResource;

    private bool disposed = false;

    // Константы для вызова CreateFile
    private const uint GENERIC_READ = 0x80000000;
    private const uint GENERIC_WRITE = 0x40000000;
    private const uint OPEN_EXISTING = 3;
    private const uint FILE_ATTRIBUTE_NORMAL = 0x80;

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr CreateFile(
        string lpFileName,
        uint dwDesiredAccess,
        uint dwShareMode,
        IntPtr lpSecurityAttributes,
        uint dwCreationDisposition,
        uint dwFlagsAndAttributes,
        IntPtr hTemplateFile);

    [DllImport("kernel32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool CloseHandle(IntPtr hObject);

    public ResourceHandler(string filePath)
    {
        // Инициализация управляемого ресурса
        managedResource = new FileStream(filePath, FileMode.OpenOrCreate);

        // Инициализация неуправляемого ресурса с использованием CreateFile
        unmanagedResource = CreateFile(
            filePath,
            GENERIC_READ | GENERIC_WRITE,
            0,
            IntPtr.Zero,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            IntPtr.Zero);

        if (unmanagedResource == IntPtr.Zero)
        {
            throw new IOException("Unable to open file.", Marshal.GetLastWin32Error());
        }
    }

    // Деструктор
    ~ResourceHandler()
    {
        Dispose(false);
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!disposed)
        {
            if (disposing)
            {
                // Освобождение управляемых ресурсов
                if (managedResource != null)
                {
                    managedResource.Dispose();
                    managedResource = null;
                }
            }

            // Освобождение неуправляемых ресурсов
            if (unmanagedResource != IntPtr.Zero)
            {
                CloseHandle(unmanagedResource);
                unmanagedResource = IntPtr.Zero;
            }

            disposed = true;
        }
    }
}
```

Блок if (disposing) в методе Dispose(bool disposing) используется исключительно для освобождения управляемых ресурсов.

Финализатор (деструктор):
Вызывает Dispose(false) для освобождения только неуправляемых ресурсов, если метод Dispose не был вызван явно.

Метод Dispose:
Явный вызов этого метода освобождает как управляемые, так и неуправляемые ресурсы, а затем вызывает GC.SuppressFinalize(this), чтобы предотвратить вызов финализатора.

Метод GC.SuppressFinalize(this) используется для предотвращения вызова метода Finalize для объекта. Это полезно, когда объект уже освободил свои ресурсы и вызов Finalize больше не требуется.

Метод Dispose(bool disposing):
Если disposing равно true, освобождаются как управляемые (managedResource), так и неуправляемые ресурсы (unmanagedResource).
Если disposing равно false, это означает, что метод был вызван из финализатора, и освобождаются только неуправляемые ресурсы, так как управляемые ресурсы могли быть уже финализированы сборщиком мусора.

**Для чего в .NET используется конструкция using(…){…}? Причем тут IDisposable?**
Значение Using непосредственно связано с интерфейсом IDisposable. Интерфейс IDisposable представляет нам возможность быстро освободить общие ресурсы, не полагаясь на автоматический сборщик мусора (garbage collector). Конструкция Using позволяет вызывать метод Dispose автоматически, как только нужный объект выйдет за блок Using.

```csharp
using (var resource = new Resource("example.txt"))
        {
            resource.Write("Hello, World!");
        }
        
        // Эквивалентный код без использования using
        var anotherResource = new Resource("another_example.txt");
        try
        {
            anotherResource.Write("Hello, Universe!");
        }
        finally
        {
            if (anotherResource != null)
            {
                anotherResource.Dispose();
            }
        }
```

**GC.Collect()**

Метод GC.Collect() инициирует сборку мусора вручную. Обычно GC работает автоматически, но иногда может потребоваться явный вызов GC.Collect(), например, для тестирования или в критических ситуациях с управлением памятью.

```csharp
GC.Collect();
```

Использование этого метода следует ограничить, так как частые вызовы могут негативно сказаться на производительности приложения из-за высоких накладных расходов на сборку мусора.

## Garbage Collector - end

---

# .NET

# Вариантность и контрвариантность в C#

## Введение

Вариантность и контрвариантность определяют, как параметры обобщенных типов могут изменяться в иерархии наследования. Эти концепции особенно важны при работе с обобщениями (generics) в C#. Вариантность применяется к интерфейсам и делегатам и позволяет указать, могут ли **параметры обобщенного типа** использоваться как **более конкретный** (ковариантность) или **более общий** тип (контрвариантность).

## Ковариантность (Covariance)

### Описание

Ковариантность позволяет использовать более конкретный тип (подтип) вместо более общего типа. Это означает, что вы можете присвоить значение с типом производного класса переменной типа базового класса, если обобщенный тип объявлен как ковариантный. Она поддерживается для выходных параметров обобщенного типа.

### Пример

```csharp
public interface ICovariant<out T>
{
    T GetItem();
}

public class Animal { }
public class Dog : Animal { }

public class CovariantExample : ICovariant<Dog>
{
    public Dog GetItem()
    {
        return new Dog();
    }
}

public class Program
{
    public static void Main()
    {
        ICovariant<Dog> dog = new CovariantExample();
        ICovariant<Animal> animal = dog; // Ковариантность позволяет это присваивание

        Animal myAnimal = animal.GetItem();
        Console.WriteLine(myAnimal.GetType().Name); // Output: Dog
    }
}
```

## **Описание ключевого слова out**
- Ключевое слово out перед параметром типа T в объявлении интерфейса указывает на ковариантность.
- Ковариантность применима к возвращаемым значениям методов (выходным параметрам).

## Контрвариантность (Contravariance)

### Описание

Контрвариантность означает, что вы можете присвоить значение с типом базового класса переменной типа производного класса, если обобщенный тип объявлен как контрвариантный. Она поддерживается для входных параметров обобщенного типа.

```csharp
public interface IContravariant<in T>
{
    void SetItem(T item);
}

public class Animal { }
public class Dog : Animal { }

public class ContravariantExample : IContravariant<Animal>
{
    public void SetItem(Animal item)
    {
        Console.WriteLine(item.GetType().Name);
    }
}

public class Program
{
    public static void Main()
    {
        IContravariant<Animal> animal = new ContravariantExample();
        IContravariant<Dog> dog = animal; // Контрвариантность позволяет это присваивание

        dog.SetItem(new Dog()); // Output: Dog
    }
}
```

### **Описание ключевого слова in**
- Ключевое слово in перед параметром типа T в объявлении интерфейса указывает на контрвариантность.
- Контрвариантность применима к параметрам методов (входным параметрам).

## Инвариантность (Invariance)

### Описание
- Инвариантность означает, что обобщенный тип не поддерживает ни ковариантность, ни контрвариантность. Параметры обобщенного типа должны точно соответствовать указанному типу.

```csharp
public interface IInvariant<T>
{
    T GetItem();
    void SetItem(T item);
}

public class Animal { }
public class Dog : Animal { }

public class InvariantExample : IInvariant<Dog>
{
    public Dog GetItem()
    {
        return new Dog();
    }

    public void SetItem(Dog item)
    {
        Console.WriteLine(item.GetType().Name);
    }
}

public class Program
{
    public static void Main()
    {
        IInvariant<Dog> dog = new InvariantExample();
        // IInvariant<Animal> animal = dog; // Ошибка компиляции: нельзя присвоить IInvariant<Dog> переменной типа IInvariant<Animal>
    }
}
```

## Заключение
- Ковариантность (out) позволяет использовать подтип вместо более общего типа для выходных параметров.
- Контрвариантность (in) позволяет использовать более общий тип вместо подтипа для входных параметров.
- Инвариантность не позволяет изменять тип параметра обобщенного типа.

**Что такое Boxing и Unboxing?**

Упаковка (boxing) позволяет преобразовать ***значимый*** тип в ***ссылочный***. При упаковке объекта значимого типа происходят следующие действия:

* Выделяется память в управляемой куче.
* Совершается копирование полей размерного типа в память, которая была выделена в куче.
* Возвращается адрес объекта.

Процесс извлечения адреса полей из упакованного объекта называется распаковкой (unboxing). Распаковка не является полной противоположностью упаковке. В отличие от упаковки при распаковке не происходит никакого копирования. Однако обычно вслед за распаковкой следует копирование полей, поэтому обе операции (распаковка и копирование) являются противоположностью операции упаковки.

Упаковка и распаковка/копирование снижают производительность приложения как в плане замедления, так и в расходе дополнительной памяти, поэтому нужно стараться минимизировать создание кода, в котором происходят операции упаковки и распаковки/копирования.

Когда может потребоваться использование упаковки и распаковки:

* Методы, принимающие параметры типа object: Если метод принимает параметр типа object, передача значения типа-значения приведет к упаковке.
* Полиморфизм: При использовании полиморфизма, когда метод работает с типом object, чтобы обеспечить работу с любыми типами данных
* Работа с немодифицируемыми API: Иногда приходится работать с API, которые требуют типы object, даже если у вас есть значение типа-значения.
* Интерфейсы: При передаче значений типов-значений методам, которые принимают интерфейсные типы, реализуемые этими значениями, происходит упаковка.

Предположим, у нас есть интерфейс ***IPrintable*** и структура ***Point***, ***реализующая*** этот интерфейс. Когда мы передаем экземпляр ***Point*** в ***метод***, который ***принимает параметр типа IPrintable***, происходит ***упаковка***.

**В чем различие между классом и структурой?**

Для С# классы System.Object, System.Exception, System.File-Stream и System.Random — это ссылочные типы (память выделяется из упр. кучи).
В свою очередь размерные (значимые) типы в документации называются структурами (structure) и перечислениями (enumeration). Например, структуры System.Int32, System.Boolean, System.Decimal, System.TimeSpan и перечисления System.DayOfWeek, System.10.FileAttributes и System.Drawing.FontStyle являются размерными типами (хранятся обычно в стеке потока, но могут быть встроены в ссылочные типы).

## Scope функции

**Scope (область видимости) функции** определяет контекст, в котором переменные определены и доступны для использования. Переменные, объявленные внутри функции (локальные переменные), имеют область видимости этой функции. Они существуют в стеке памяти, который является структурой данных типа LIFO (Last In, First Out).

## Когда и при каких условиях очищаются данные переменных, которые хранятся в стеке?

1. **Создание переменной**:
   - Когда функция вызывается, для неё выделяется новый фрейм в стеке, в котором хранятся все локальные переменные этой функции.
   
2. **Очистка переменных**:
   - Когда выполнение функции завершается (независимо от того, как функция была завершена: нормальный выход, исключение и т.д.), фрейм стека для этой функции удаляется.
   - Все локальные переменные, находящиеся в этом фрейме, автоматически уничтожаются и память освобождается.
 
## Что такое фрейм в стеке?

**Фрейм в стеке** (stack frame) — это область памяти, выделяемая в стеке при вызове функции. Каждый фрейм в стеке содержит:
- Локальные переменные функции
- Параметры функции
- Адрес возврата (адрес, куда программа должна вернуться после завершения функции)
- Регистр базы фрейма (или указатель стека для предыдущего фрейма)

Когда вызывается функция, создается новый фрейм в стеке, и когда функция завершается, этот фрейм удаляется.

## Как удаляется переменная из стека

Переменная, объявленная внутри функции, живет до тех пор, пока не завершится выполнение этой функции. Переменные не удаляются индивидуально из стека, вместо этого удаляется весь фрейм стека.

### Пример

```csharp
void FunctionA()
{
    int a = 10;
    FunctionB();
    int b = 20;
}

void FunctionB()
{
    int c = 30;
    // Некоторые операции
}
```

## Порядок выполнения и удаление фреймов

- Вызов FunctionA:
  - Создается фрейм в стеке для FunctionA.
  - Переменная a сохраняется в этом фрейме.

- Вызов FunctionB из FunctionA:
  - Создается новый фрейм в стеке для FunctionB.
  - Переменная c сохраняется в фрейме FunctionB.

- Завершение FunctionB:
  - Фрейм FunctionB удаляется из стека.
  - Переменная c удаляется вместе с фреймом FunctionB.

- Возвращение в FunctionA:
  - Выполняется код после вызова FunctionB.
  - Переменная b сохраняется в фрейме FunctionA.

- Завершение FunctionA:
  - Фрейм FunctionA удаляется из стека.
  - Переменные a и b удаляются вместе с фреймом FunctionA.

## Заключение

Фрейм в стеке — это блок памяти, выделяемый для выполнения функции, который содержит ***локальные переменные, параметры функции, адрес возврата и регистр базы фрейма***.
Переменные в стеке удаляются не индивидуально, а вместе с фреймом, когда функция завершается.
Удаление фрейма происходит, когда выполнение функции завершено, что освобождает всю память, занятую этим фреймом.
Таким образом, переменная из стека будет удалена только тогда, когда завершится выполнение функции, которой она принадлежит, и весь фрейм функции будет удален.

- **Название метода**: Имена методов не хранятся в стеке. Они хранятся в метаданных сборки и используются компилятором и рантаймом для различных операций, таких как вызов методов и отладка.
- **Стек**: Используется для хранения параметров функции, локальных переменных и адресов возврата при вызове функций.
- **Фреймы стека**: Создаются и удаляются по мере вызова и завершения функций.

# Хранение Value Type в стеке и в куче

**Value types** включают примитивные типы (например, `int`, `float`, `bool`), структуры (`struct`) и перечисления (`enum`). Хранение переменных типа значений зависит от контекста, в котором они объявлены:

## В стеке:

- **Локальные переменные**: Переменные типа значений, объявленные внутри функции, хранятся в стеке.
  ```csharp
  void Function()
  {
      int x = 10; // 'x' хранится в стеке
  }
  ```

- **Параметры метода**: Параметры метода, передаваемые по значению, также хранятся в стеке.
  ```csharp
  void Function(int param)
  {
      // 'param' хранится в стеке
  }
  ```

## В куче:

- **Члены класса**: Переменные типа значений, являющиеся полями класса, хранятся в куче вместе с экземпляром класса.
  ```csharp
  class MyClass
  {
      public int value; // 'value' хранится в куче вместе с экземпляром MyClass
  }
  ```

- Закрытые переменные анонимных методов и лямбд: Если переменная захвачена лямбдой или анонимным методом, она может быть перемещена в кучу.
  ```csharp
  void Function()
  {
      int captured = 10;
      Action action = () => Console.WriteLine(captured); // 'captured' может быть перемещен в кучу
  }
  ```

## Структура vs Класс: Что быстрее и когда использовать?

### Структура

* **Быстрее в некоторых случаях**: Структуры могут быть быстрее, так как они обычно хранятся в стеке, что обеспечивает быстрый доступ и автоматическое управление временем жизни.
* **Меньше накладных расходов**: Структуры не требуют аллокации в куче и сборки мусора.
* **Использование**: 
  * **Маленькие и простые объекты**: Используйте структуры для небольших и часто используемых объектов, таких как точки, комплексные числа или цветовые модели.
  * **Immutable объекты**: Структуры должны быть неизменяемыми (immutable) для избежания проблем с изменением данных.
  * **Когда наследование не нужно**: Структуры не поддерживают наследование, поэтому подходят только для простых объектов, не требующих полиморфизма.

### Класс

* **Более гибкие**: Классы поддерживают наследование, полиморфизм и интерфейсы, что делает их более гибкими для сложных объектов.
* **Управление временем жизни**: Объекты классов хранятся в куче, и их время жизни управляется сборщиком мусора, что упрощает управление памятью для длительных объектов.
* **Использование**:
  * **Сложные объекты**: Используйте классы для более сложных объектов, требующих наследования и полиморфизма.
  * **Объекты с длительным временем жизни**: Классы подходят для объектов, которые должны существовать в течение долгого времени и управляются сборщиком мусора.

---

# Делегаты, события

**Чем отличается event от delegate?**

Delegate – это по сути указатель на функцию.

В С# модель издатель — подписчик, где класс публикует событие, которое он может инициировать, и любые классы могут подписаться на это событие. Метод, вызываемый при возникновении события, определяется делегатом.

---

# Модификаторы доступа

* public: Доступен всем.
* private: Доступен только внутри своего класса.
* protected: Доступен внутри своего класса и производных классов.
* internal: Доступен только внутри текущей сборки.
* protected internal: Доступен внутри текущей сборки и производных классов.
* private protected: Доступен внутри текущего класса и производных классов в той же сборке.

---

**Что обозначает термин immutable (неизменяемый)?**

Это значит, что данные, хранящиеся в переменной, не могут быть изменены. При этом заметьте, что значение переменной может быть изменено - путём отказа от использования старых данных, которые могут быть изменены. Оригинальные данные остаются в памяти, а новые значения создаются вновь, в новой области памяти. Пример тип String.

**Какая разница между классами System.String и System.Text.StringBuilder?**

***Данные, хранящиеся в классе System.String и есть неизменяемые (immutable)***. Класс System.StringBuilder разрабатывался так, чтобы над изменяемой строкой можно было проделать множество операций. То есть при каждой операции над объектом класса System.String происходит перенос данных в новую область памяти, что влияет на производительность программы.

**Какое преимущество использования класса System.Text.StringBuilder перед System.String?**

Класс StringBuilder более эффективен в случае работы с большим количеством строк. Объекты класса System.String неизменяемы, поэтому при каждом изменении строки создаётся новый объект в памяти.

---

# Массивы

**Объясните разницу между System.Array.CopyTo() и System.Array.Clone()?**

Первая операция осуществляет глубокое копирование массива, а вторая – поверхностное. Поверхностное копирование массива копирует только сами элементы объекта класса Array, независимо от того являются они ссылочными или значимыми типами. Копирования объектов, на которые ссылаются ссылочные типы не происходит. Ссылки в новом объекте класса Array указывают на те же объекты, что и ссылки в оригинальном массиве Array. Глубокое копирование копирует как элементы класса Array, так и объекты, на которые они явно или неявно ссылаются.

---

# Приведение типов

**as, is – что это, как применяется?**

С помощью оператора ***as*** программа пытается преобразовать выражение к определенному типу, при этом не выбрасывает исключение. В случае неудачного преобразования выражение будет содержать значение null.

---

**В чем разница между throw ex; и throw;?**

***throw*** повторно выбрасывает исключение (***re-throw***), которое было обнаружено, и сохраняет трассировку стека (путь к источнику исключения).
***throw ex*** генерирует одно и то же исключение, но сбрасывает трассировку стека на метод, где делается ***throw ex***.

**Как работает return в try-catch-finally?**

Алгоритм приблизительно такой:

* Выполняется код перед оператором return;
* Выражение в return оценивается
* Выполняется finally блок
* Возвращается результат, посчитанный на шаге 2

---

# Классы

## Назовите класс .NET, от которого наследуются все классы?

System.Object.

## В каком случае вы обязаны объявить класс абстрактным?

В том случае, если класс является наследником абстрактного класса, но не все методы базового класса перекрыты и имеют реализацию.
В том случае, если хотя бы один метод класса является абстрактным

## Как работает Equals в C#?

В классе System.Object есть все несколько методов, один из них ReferenceEquals

Стоить отметить, что == и RefefenceEquals работает идентично, сравнивая ссылки на объекты в куче

```csharp
 public static bool Equals(Object objA, Object objB) 
    {
        if (objA==objB) {
            return true;
        }
        if (objA==null || objB==null) {
            return false;
        }
        return objA.Equals(objB);
    }
```

**Сравнение Value типов через Equals**

* Проверяет можно ли сделать побитовое сравнение, если да, то выполняется FastEqualsCheck(Object a, Object b);
* Если же это не побитовое сравнение, применяется рефлексия, и значения всех полей сравниваются попарно через Equals(object).

> Если структура содержит поля, которые являются ссылочными типами, следует переопределить метод Equals(Object). Это может повысить производительность и позволить более точно представить значение равенства для типа. Так как при большом количестве полей, выполнение ValueType.Equals может быть очень затратным по времени. При переопределении так же не забывайте переопределять и метод GetHashCode который используется в таких типах данных как Dictionary для сравнения объектов.

**IEqualityComparer**

Если вам нужен метод для сравнения объектов для конкретного типа, а не общей ситуации (или вы хотите сравнивать специальным образом объекты, которые вам не принадлежат), вы можете делегировать сравнение специальному объекту, реализующему интерфейс IEqualityComparer или типизированный IEqualityComparer<T>. Сравнение при помощи таких сравнивающих объектов применяют, например, Hashatable и Dictionary<K, V>, а также некоторые LINQ-методы.

К этому интерфейсу есть и его реализация с помощью EqualityComparer<T>. EqualityComparer<T>, он проверяет реализует ли объект интерфейс IEquatable<T>, и в противном случае выполняет сравнение через стандартный Equal(object). При реализации IEqualityComparer рекомендуется  наследоваться от EqualityComparer.

**IComparable**

Проверка на равенство так же может быть выполнена  через сравнение больше/меньше/равно. Для этого используются операторы сравнения </>, интерфейсы IComparable (аналог метода Equals(object)), IComparable<T> (аналог интерфейса IEquatable<T>)


## Делегаты

Делегат представляет собой объект, который может ссылаться на метод или несколько методов. Следовательно, когда создается делегат, то в итоге получается объект, содержащий ссылку на метод. Иными словами, делегат позволяет вызывать метод, на который он ссылается.

По сути, делегат — это безопасный в отношении типов объект, указывающий на другой метод (или, возможно, список методов) приложения, который может быть вызван позднее. В частности, объект делегата поддерживает три важных фрагмента информации:

адрес метода, на котором он вызывается;
аргументы (если есть) этого метода;
возвращаемое значение (если есть) этого метода.

```csharp
class TrainStation
    {
        delegate int Train();

        int Wagon1()
        {
            Console.WriteLine("wagon1 is running");
            return 1;
        }

        int Wagon2()
        {
            Console.WriteLine("wagon2 is running");
            return 2;
        }
        public void CreateTrain()
        {
            Train train = Wagon1; 
            train += Wagon2;
            train  += () => // пример с использованием лямбда выражения
            {
                Console.WriteLine("wagon3 is running");
                return 3; 
            };

            Console.WriteLine("WagonNumber:" + train());
        }
    }
    internal class Program
    {
       
        private static void Main()
        {
            var trainStation = new TrainStation();
            trainStation.CreateTrain();
            Console.ReadKey();
        }
    }
```

На экран выведется следующее:

    wagon1 is running
    wagon2 is running
    wagon3 is running
    WagonNumber:3

## В чем разница между ключевыми словами new и override при переопределении метода класса?

Модификатор override расширяет метод virtual базового класса, а модификатор new скрывает доступный метод базового класса.

# Типы данных, коллекции и структуры данных в .NET

## Dictionary

Под капотом класса Dictionary<TKey, TValue> в .NET используется структура данных, называемая хэш-таблицей. Хэш-таблица позволяет ассоциировать ключи с соответствующими значениями, обеспечивая быстрый доступ к элементам по ключу.

Основные элементы хэш-таблицы
- Массив корзин (buckets):

  > Это массив, где каждый элемент представляет собой индекс (или ссылку) на связанный список элементов (в некоторых реализациях может использоваться массив или другая структура).
  > Индекс массива определяется хэш-кодом ключа.

- Список записей (entries):

  Это массив структур, каждая из которых содержит:
  - Хэш-код ключа.
  - Ключ.
  - Значение.
  - Индекс следующей записи в случае коллизии (следующая запись в связном списке).

**Принципы работы хэш-таблицы**

- Хэширование:
  - При добавлении элемента вычисляется хэш-код ключа.
  Этот хэш-код используется для определения индекса в массиве корзин.
- Коллизии:
  - Коллизия происходит, когда два ключа имеют одинаковый хэш-код. В Dictionary<TKey, TValue> для разрешения коллизий используется метод цепочек (chaining): в каждой корзине хранится связанный список записей, которые имеют одинаковый хэш-код.
- Добавление элемента:
  - Вычисляется хэш-код ключа.
  - Определяется индекс корзины.
  - Если корзина пуста, запись добавляется напрямую.
  - Если корзина уже содержит элементы, новая запись добавляется в начало или конец связанного списка.
- Поиск элемента:
  - Вычисляется хэш-код ключа.
  - Определяется индекс корзины.
  - Проход по связанному списку записей в корзине до нахождения нужного ключа.

Dictionary использует метод GetHashCode() класса Object для вычисления целого числа которое используется для поиска индекса для вставки нового значения.

Реализовывая свой кастомный GetHashCode() вы должны удовлетворить следующие требования:

- Один и тот же объект должен всегда возвращать одинаковый хэш-код (Хэш-код не должен изменятся во время жизни объекта).
- Разные объекты могут возвращать одно и то же значение хэш-кода.
- Метод должен выполняться очень быстро.
- Он не должен генерировать эксепшенов.
- Он должен использовать как минимум одно поле экземпляра.
- Значения хэш-кода должны распределяться равномерно по всему диапазону чисел, которые может хранить int.

При удалении мы удаляем содержимое ячеек значениями по умолчанию, меняем указатели next других элементов при неоходимости и сохраняем индекс этого элемента во внутреннее поле freeList, а старое в поле next. Таким образом, при добавлении нового элемента мы можем повторно использовать такие свободные ячейки
## ListDictionary

Это простая реализация IDictionary с использованием односвязного списка. Она меньше и быстрее, чем Hashtable, если количество элементов равно 10 или меньше. Лучше не использовать этот класс, если вам важна производительность для большого количества элементов.

Принимает  в качестве параметров тип Object.

Пример инициализации:

```csharp
var dictionary = new ListDictionary
{
     { "key", "value"}
};
```

## HybridDictionary

Гибридная версия между ListDictionary и HashTable. До 10 элементов гибрит использует ListDictionary элементов если же коллекция становится больше чем 10 элементов, он переключается на работу с HashTable

## OrderedDictionary

Иногда бывают моменты когда вы хотите использовать ключи для поиска или foreach для итерации с помощью DictionaryEntry объектов. Элементы OrderedDictionary доступны с помощью ключа или индекса .Элементы OrderedDictionary не сортируются по ключу, в отличие от элементов SortedDictionary<TKey,TValue> класса который мы рассматриваем выше. 

Другим преимуществом OrderedDictionary является скорость. При просмотре большой коллекции чтение OrderedDictionary с использованием первого примера, числового индекса, всегда будет быстрее, чем при использовании метода стиля словаря.

Когда вам нужна "мощь" коллекции и простой доступ к числовому индексу, OrderedDictionary является предпочтительной коллекцией.

## SortedDictionary

Класс SortedDictionary<TKey, Tvalue> представляет дерево бинарного поиска, в котором все элементы отсортированы на основе ключа. Тип ключа должен реализовать интерфейс IComparable<TKey>. Если тип ключа не сортируемый, компаратор можно также создать, реализовав IComparer<TKey> и указав его в качестве аргумента конструктора сортированного словаря.

Классы SortedDictionary<TKey, Tvalue> и SortedList<TKey, TValue> часто сравнивают друг с другом, так как они имеют схожий функционал. Но поскольку SortedList<TKey, TValue> реализован в виде списка, основанного на массиве, a SortedDictionary<TKey, Tvalue> реализован как словарь, эти классы обладают разными характеристиками:

SortedList<TKey, TValue> использует меньше памяти, чем SortedDictionary<TKey, TValue>
SortedDictionary<TKey, TValue> быстрее вставляет и удаляет элементы.

При наполнении коллекции отсортированными данными SortedList<TKey,TValue> работает быстрее, если при этом не требуется изменение размера.

## ConcurrentDictionary

Представляет потокобезопасную коллекцию пар "ключ-значение", доступ к которой могут одновременно получать несколько потоков.

Для настройки есть 2 основных параметра:
- сapacity — первоначальное кол-во элементов. По умолчанию — 31.
- concurrencyLevel – предполагаемое число потоков на запись. По умолчанию = 4

Ниже примерный алгоритм работы:

- Вычисление хеша ключа нового элемента
- Вычисление бакета bucketNo, в который будет добавлен элемент, и номера блокировки из пула
- Блокировка bucketNo через Monitor.Enter
- Запись элемента с использованием Volatile.Write
- Освобождение блокировки Monitor.Exit

## ImmutableDictionary и ReadOnlyDictionary

ReadOnlyDictionary можно инициализировать всего один раз через конструктор, После вы не сможете добавлять или удалять в него элементы. Это полезно, если вы хотите убедиться, что он не будет изменен, пока он будет отправлен через несколько уровней вашего приложения. Вы инициализируете ReadOnlyDictionary, передавая другой экземпляр слова конструктору. Это объясняет, почему ReadOnlyDictionary является изменяемым (если базовый словарь изменен). Это просто оболочка, защищенная от прямых изменений.

В ImmutableDictionary есть методы для его модификации, такие как " Add или " Remove, но они создадут новый словарь и вернут его, исходный останется без изменений и вернется копия нового неизменяемого словаря. ImmutableDictionary является потокобезопасным, потому что вы не можете изменить исходный экземпляр (ни прямо, ни косвенно). Все методы, которые "изменяют", фактически возвращают новый экземпляр.

## IEnumerable vs IQueryable

Коллекции реализуют интерфейс IEnumerable<T> явно или неявно. Так как тип Array не является Generic типом, то он наследует только IEnumerable, а не IEnumerable<T>.  

Интерфейс IEnumerable указывает, что тип реализует GetEnumerator. Благодаря чему для него доступна конструкция foreach. С IEnumerable часто используются расширения из System.Linq. Generic интерфейс используется при возвращении из запросов (например к базе данных или к другим коллекциям).

IEnumerable подходит для перебора по коллекции и отображения результатов на фронтенде. Вы не можете изменить (добавить или удалить) данные из IEnumerable. В случае запроса к базе данных на сервере запрос вернет все данные (без фильтров) как это показано в абстрактной картинке ниже.

## IQueryable

Всякий раз, когда мы сталкиваемся с большим количеством данных необходимо подумать, какую коллекцию или какой тип использовать для работы с ними. В отличии от IEnumerable – IQueryable предлагает высокую производительность в случае работы с большим объемом данных. IQueryable предварительно фильтрует данные по запросу а затем отправляет только отфильтрованные данные клиенту.

## Разница между IQueryable и IEnumerable

Основное отличие между этими интерфейсами в том, что IEnumerable работает со всем массивом данных, а IQueryable с отфильтрованным. IEnumerable получает все данные на стороне сервера и загружает их в память а затем позволяет сделать фильтрацию по данным из памяти. Когда делается запрос к базе данных, IQueryable выполняет запрос на серверной стороне и в запросе применяет фильтрацию. 

Вот отличные картинки для сравнения этих 2х методов обращения к базе

## Когда что использовать?
**IEnumerable**

- IEnumerable может двигаться только вперед по коллекции, он не может идти назад
- Хорошо подходит для работы с данными в памяти (списки, массивы)
- Подходит для LINQ to Object и LINQ to XML
- Поддерживает отложенное выполнение (Lazy Evaluation)
- Не поддерживает произвольные запросы
- Не поддерживает ленивую загрузку (lazy loading)
- Методы расширения, работающие с IEnumerable принимают функциональные объекты

**IQueryable**

- IQueryable может двигаться только вперед по коллекции, он не может идти назад
- IQueryable лучше работает с запросами к базе данных (вне памяти)
- Подходит для LINQ to SQL
- Поддерживает отложенное выполнение (Lazy Evaluation)
- Поддерживает произвольные запросы (используя CreateQuery и метод Execute)
- Поддерживает ленивую загрузку (lazy loading)
- Методы расширения, работающие с IQueryable принимают объекты выражения (expression tree)

Основные компоненты IQueryable<T>
- Expression: Свойство типа Expression, которое хранит дерево выражений, представляющее запрос.
- Provider: Свойство типа IQueryProvider, которое отвечает за выполнение запроса, описанного в дереве выражений.

**Как LINQ-запрос преобразуется в SQL**
LINQ-запросы преобразуются в SQL благодаря деревьям выражений и провайдеру запросов. Рассмотрим, как это происходит шаг за шагом.

- Построение дерева выражений:
  - Когда вы пишете LINQ-запрос, компилятор C# создает дерево выражений, представляющее этот запрос. Это дерево выражений сохраняется в свойстве Expression объекта IQueryable<T>.
- Передача дерева выражений провайдеру:
  - Объект IQueryable<T> передает дерево выражений своему провайдеру, который реализует интерфейс IQueryProvider.
- Компиляция дерева выражений в SQL:
  - Провайдер запросов анализирует дерево выражений и генерирует соответствующий SQL-запрос. Это включает в себя преобразование методов LINQ (например, Where, Select, OrderBy) в SQL-команды.
- Выполнение SQL-запроса:
  - Провайдер запросов отправляет сгенерированный SQL-запрос на выполнение базе данных.
  - Результаты выполнения SQL-запроса возвращаются и преобразуются в объекты .NET, которые затем возвращаются как IEnumerable<T>.

## Разница между Array, List

В C# и .NET Framework Array и List являются коллекциями, которые используются для хранения множества элементов. Однако у них есть ключевые различия в функциональности, производительности и использовании.

**Array**

Основные характеристики:
- Фиксированный размер: Размер массива задается при его создании и не может быть изменен.
- Типизированный: Все элементы массива должны быть одного типа.
- Быстрый доступ: Доступ к элементам массива осуществляется за время O(1), что делает массивы очень быстрыми для доступа к элементам по индексу.
- Низкий уровень: Массивы – это более низкоуровневая структура данных, что означает меньший оверхед.

**List**

Основные характеристики:
- Динамический размер: List<T> может автоматически изменять свой размер при добавлении или удалении элементов.
- Удобные методы: List<T> предоставляет множество методов для управления коллекцией, таких как Add, Remove, Insert, Contains, Sort и т.д.
- Типизированный: List<T> является обобщенной коллекцией (generic), что позволяет использовать любой тип данных.
- Гибкость: List<T> удобен для работы с коллекциями переменной длины.
  
Под капотом класса List<T> в .NET используется массив для хранения элементов. Это позволяет List<T> обеспечивать быстрый доступ к элементам по индексу и эффективное использование памяти. Однако, так как массив имеет фиксированный размер, List<T> реализует механику изменения размера внутреннего массива для поддержки динамического добавления элементов.

Внутренние механизмы List<T>
- Внутренний массив:
    - В List<T> есть внутреннее поле, которое представляет собой массив типа T[]. Этот массив используется для хранения элементов списка.
- Изменение размера:
    - Когда вы добавляете элемент в List<T> и текущий массив не имеет достаточно места для нового элемента, List<T> создает новый массив, который обычно в два раза больше текущего.
    - Существующие элементы копируются в новый массив, после чего старый массив удаляется. Это позволяет увеличить емкость списка и минимизировать количество перераспределений памяти.
  
Основные моменты:
- Начальная емкость: начальная емкость массива установлена на 0, после при первом добавлении увеличивается до 4
- Изменение размера: Когда _size достигает текущей длины _items, создается новый массив в два раза больше, и элементы копируются в новый массив.
- Доступ по индексу: Осуществляется за время O(1) благодаря использованию массива.

## Оператор yield

В C# оператор yield используется для упрощения создания итераторов. Он позволяет определять методы, которые могут возвращать элементы последовательности по одному, вместо того чтобы сначала создавать целую коллекцию. Использование yield делает код более читаемым и менее затратным по памяти, особенно для больших коллекций.

Когда компилятор C# встречает yield return или yield break, он автоматически создает состояние машины (state machine), которая управляет процессом итерации. Это позволяет методу запомнить своё текущее состояние и продолжить выполнение с того места, где он был прерван при следующем вызове итератора.

**Преимущества использования yield**

- Простота и читабельность кода: Оператор yield позволяет писать итераторы без явного использования вспомогательных коллекций и контроля состояния.
- Экономия памяти: Не нужно заранее создавать всю коллекцию в памяти. Элементы генерируются по мере необходимости.
- Удобство обработки больших данных: С помощью yield можно обрабатывать и возвращать большие наборы данных по частям.

## LinkedList

- Двусвязный список:
  - Каждый элемент (узел) списка содержит ссылку на следующий и предыдущий элемент.
  - Это позволяет легко вставлять и удалять элементы, зная только ссылки на соседние узлы.

- Отсутствие индексов:
  - В отличие от массива или списка, LinkedList не поддерживает произвольный доступ по индексу. Элементы нужно обходить начиная с головы или хвоста.

- Эффективные операции вставки и удаления:
  - Вставка и удаление элементов в любом месте списка выполняются за время O(1), если известна позиция (ссылка на узел).
  - Операции поиска элементов требуют времени O(n), так как требуется последовательный обход списка.

```csharp
  LinkedList<int> linkedList = new LinkedList<int>();

  // Добавление элементов в начало и конец списка
  linkedList.AddLast(1);
  linkedList.AddLast(2);
  linkedList.AddFirst(0);

  // Вставка элемента после определенного узла
  LinkedListNode<int> node = linkedList.Find(1);
  linkedList.AddAfter(node, 1);

  // Удаление элемента
  linkedList.Remove(1);

  // Перебор элементов списка
  foreach (int value in linkedList)
  {
      Console.WriteLine(value);
  }
```

**Задачи, для которых может быть нужен LinkedList**

- Частые вставки и удаления элементов:
  - Если нужно часто вставлять или удалять элементы в середине коллекции, LinkedList может быть эффективнее, чем List<T>, где такие операции требуют сдвига элементов.
- Работа с коллекциями, размер которых неизвестен заранее:
  - LinkedList хорош для коллекций, размер которых изменяется во время выполнения программы.
- Сложные операции на основе указателей:
  - В некоторых алгоритмах требуется сложная манипуляция указателями на элементы, что может быть проще реализовано с использованием LinkedList.

**Заключение**

LinkedList полезен в сценариях, где необходимо часто вставлять и удалять элементы в середине списка, а также в алгоритмах, где требуется сложная манипуляция указателями. Однако, для задач, требующих быстрого произвольного доступа по индексу, List<T> или массивы могут быть предпочтительнее.

## Tree, Graph

**Для каких задач могут пригодиться графы и деревья**

Графы:
- Социальные сети: Моделирование связей между пользователями.
- Поиск путей: Алгоритмы поиска кратчайшего пути, такие как алгоритм Дейкстры или A*.
- Оптимизация сети: Задачи маршрутизации и сетевого анализа.
- Обработка естественного языка: Графы слов и синтаксические деревья.

Деревья:
- Базы данных: Индексы (например, B-деревья и B+-деревья).
- Парсинг выражений: Деревья разбора для компиляторов и интерпретаторов.
- Иерархические данные: Организационные структуры, файловые системы.
- Быстрый поиск: Двоичные деревья поиска и их вариации (AVL-деревья, красно-черные деревья).

# Потокобезопасность

## Lock

lock – это конструкция в C#, которая обеспечивает эксклюзивный доступ к определённому ресурсу, чтобы избежать состояния гонки (race conditions). Когда поток заходит в блок lock, он получает эксклюзивный доступ к объекту, переданному в lock. Другие потоки, которые пытаются войти в тот же блок lock с тем же объектом, будут заблокированы, пока первый поток не выйдет из блока lock.

## Monitor
```csharp
  Monitor.Enter(syncObject);
  try
  {
      // Critical section
      return dictionary[key];
  }
  finally
  {
      Monitor.Exit(syncObject);
  }
```

## Что такое object, зачем он нужен и как он используется?

object – это базовый класс всех типов в C#. Он используется в lock в качестве маркера для блокировки. Важно, чтобы этот объект был неизменяемым и общим для всех потоков, которые должны синхронизироваться между собой.

В этом примере syncObject – это объект, который используется для синхронизации доступа к ресурсу (в данном случае – к словарю dictionary).

**Зачем нужен lock?**

lock необходим для того, чтобы обеспечить безопасность потоков при доступе к общим ресурсам. Без использования lock могут возникать следующие проблемы:

- Состояние гонки (Race conditions): несколько потоков одновременно изменяют один и тот же ресурс, что приводит к некорректным результатам.
- Повреждение данных (Data corruption): данные могут быть повреждены из-за одновременного доступа к ресурсу.
- Неопределенное поведение: результат выполнения программы может быть непредсказуемым и зависеть от порядка выполнения потоков.
- Использование lock гарантирует, что только один поток в данный момент времени имеет доступ к критической секции кода, что позволяет избежать вышеуказанных проблем.

## Semaphore

Semaphore ограничивает количество потоков, которые могут одновременно получить доступ к ресурсу или группе ресурсов. Semaphore поддерживает счетчик, который уменьшается, когда поток получает доступ к ресурсу, и увеличивается, когда поток освобождает ресурс.

```csharp
public class Example
{
    private readonly Semaphore semaphore = new Semaphore(2, 2); // Максимум 2 потока

    public void CriticalSection()
    {
        semaphore.WaitOne(); // Вход в критическую секцию
        try
        {
            // Критическая секция кода
        }
        finally
        {
            semaphore.Release(); // Выход из критической секции
        }
    }
}
```

## Mutex

Mutex похож на Monitor, но может использоваться для синхронизации потоков между разными процессами. Он предоставляет взаимное исключение на уровне операционной системы


```csharp
public class Example
{
    private readonly Mutex mutex = new Mutex();

    public void CriticalSection()
    {
        mutex.WaitOne();
        try
        {
            // Критическая секция кода
        }
        finally
        {
            mutex.ReleaseMutex();
        }
    }
}
```

## ReaderWriterLockSlim

ReaderWriterLockSlim позволяет нескольким потокам одновременно читать данные при условии, что никто не записывает, и эксклюзивно блокирует запись данных, когда поток записывает данные. Это улучшает производительность при частом чтении и редкой записи.

```csharp
public class Example
{
    private readonly ReaderWriterLockSlim rwLock = new ReaderWriterLockSlim();

    public void ReadSection()
    {
        rwLock.EnterReadLock();
        try
        {
            // Чтение данных
        }
        finally
        {
            rwLock.ExitReadLock();
        }
    }

    public void WriteSection()
    {
        rwLock.EnterWriteLock();
        try
        {
            // Запись данных
        }
        finally
        {
            rwLock.ExitWriteLock();
        }
    }
}
```

## SpinLock

SpinLock является легковесным примитивом синхронизации, который активно ожидает (спинует), пока не получит блокировку. Он полезен в сценариях, где ожидается, что блокировка будет удерживаться очень короткое время.

```csharp
public class Example
{
    private SpinLock spinLock = new SpinLock();

    public void CriticalSection()
    {
        bool lockTaken = false;
        try
        {
            spinLock.Enter(ref lockTaken);
            // Критическая секция кода
        }
        finally
        {
            if (lockTaken)
            {
                spinLock.Exit();
            }
        }
    }
}
```

## Big O notation

https://webdevblog.ru/bolshoe-o-chto-eto-takoe-pochemu-eto-vazhno-i-pochemu-eto-ne-vazhno/

**Общие классы сложности**

- O(1): Константная сложность. Время выполнения не зависит от размера входных данных.
  
  Пример: доступ к элементу массива по индексу.
  ```csharp
  public int GetElementAtIndex(int[] array, int index)
  {
      return array[index]; // Выполняется одна операция
  }
  ```
- O(n): Линейная сложность. Время выполнения растет линейно с размером входных данных.
   
    Пример: линейный поиск в неотсортированном массиве.
    ```csharp
    public bool LinearSearch(int[] array, int target)
    {
        for (int i = 0; i < array.Length; i++)
        {
            if (array[i] == target)
            {
                return true;
            }
        }
        return false;
    }
    ```
- O(log n): Логарифмическая сложность. Время выполнения растет логарифмически с размером входных данных.
   
    Пример: бинарный поиск.
    ```csharp
    public bool BinarySearch(int[] array, int target)
    {
        int left = 0;
        int right = array.Length - 1;
        while (left <= right)
        {
            int mid = left + (right - left) / 2;
            if (array[mid] == target)
            {
                return true;
            }
            if (array[mid] < target)
            {
                left = mid + 1;
            }
            else
            {
                right = mid - 1;
            }
        }
        return false;
    }
    ```
- O(n log n): Линейно-логарифмическая сложность. Обычно встречается в алгоритмах сортировки.
  
  Пример: сортировка слиянием, быстрая сортировка в среднем случае.
  ```csharp
  public void MergeSort(int[] array)
  {
      if (array.Length <= 1) return;
      int mid = array.Length / 2;
      int[] left = array.Take(mid).ToArray();
      int[] right = array.Skip(mid).ToArray();
      MergeSort(left);
      MergeSort(right);
      Merge(array, left, right);
  }

  private void Merge(int[] array, int[] left, int[] right)
  {
      int i = 0, j = 0, k = 0;
      while (i < left.Length && j < right.Length)
      {
          if (left[i] < right[j])
          {
              array[k++] = left[i++];
          }
          else
          {
              array[k++] = right[j++];
          }
      }
      while (i < left.Length)
      {
          array[k++] = left[i++];
      }
      while (j < right.Length)
      {
          array[k++] = right[j++];
      }
  }
  ```
- O(n^2): Квадратичная сложность. Время выполнения растет пропорционально квадрату размера входных данных.
  
    Пример: сортировка пузырьком, сортировка вставками.
    ```csharp
    public void BubbleSort(int[] array)
    {
        for (int i = 0; i < array.Length - 1; i++)
        {
            for (int j = 0; j < array.Length - 1 - i; j++)
            {
                if (array[j] > array[j + 1])
                {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }
    ```
- O(2^n): Экспоненциальная сложность. Время выполнения удваивается при добавлении каждого нового элемента.
  
  Пример: решение задачи коммивояжера полным перебором.
  ```csharp
  public List<List<int>> GetPowerSet(List<int> set)
  {
      List<List<int>> powerSet = new List<List<int>>();
      int powerSetCount = (int)Math.Pow(2, set.Count);
      for (int i = 0; i < powerSetCount; i++)
      {
          List<int> subset = new List<int>();
          for (int j = 0; j < set.Count; j++)
          {
              if ((i & (1 << j)) != 0)
              {
                  subset.Add(set[j]);
              }
          }
          powerSet.Add(subset);
      }
      return powerSet;
  }
  ```
- O(n!): Факториальная сложность. Время выполнения растет факториально с увеличением размера входных данных.
  
  Пример: генерация всех перестановок строки.
  ```csharp
  public List<string> GetPermutations(string str)
  {
      List<string> permutations = new List<string>();
      Permute(str.ToCharArray(), 0, str.Length - 1, permutations);
      return permutations;
  }

  private void Permute(char[] array, int left, int right, List<string> permutations)
  {
      if (left == right)
      {
          permutations.Add(new string(array));
      }
      else
      {
          for (int i = left; i <= right; i++)
          {
              Swap(ref array[left], ref array[i]);
              Permute(array, left + 1, right, permutations);
              Swap(ref array[left], ref array[i]); // backtrack
          }
      }
  }

  private void Swap(ref char a, ref char b)
  {
      char temp = a;
      a = b;
      b = temp;
  }
  ```

# Асинхронность и параллелизм в .NET

TAP (Task-based Asynchronous Pattern) — тот самый async/await (если говорить строго, то эти слова появились уже после появления подхода и типов Task и Task<TResult>, но async/await значительно улучшил эту концепцию)

Объект задачи, также имеет определенные условия, чтобы к нему можно было применить await:

- Ожидаемый тип должен иметь публичный (или internal) метод GetAwaiter(), это может быть и метод расширения. Этот метод возвращает объект ожидания
- Объект ожидания должен реализовать интерфейс INotifyCompletion, который обязывает реализовать метод void OnCompleted(Action continuation). Также он должен иметь экземплярные свойство bool IsCompleted, метод void GetResult(). Может быть как структурой, так и классом.

## За кулисами. Машина состояний

Исходный код:

```csharp
public async Task<string> GetDataAsync()
{
    HttpClient client = new HttpClient();
    string result = await client.GetStringAsync("https://example.com");
    return result;
}
```

**Метод-заглушка** — это тот метод, который вызывается внешним кодом. Он создает и запускает машину состояний.

```csharp
public Task<string> GetDataAsync()
{
    var stateMachine = new StateMachine();
    stateMachine._builder = AsyncTaskMethodBuilder<string>.Create();
    stateMachine._state = -1;
    stateMachine._builder.Start(ref stateMachine);
    return stateMachine._builder.Task;
}

```

**Машина состояний** — управляет выполнением асинхронного метода и его состояниями. Она включает в себя переменные и логику для перехода между состояниями.

```csharp
private struct StateMachine : IAsyncStateMachine
{
    public int _state;
    public AsyncTaskMethodBuilder<string> _builder;
    private HttpClient _client;
    private TaskAwaiter<string> _awaiter;

    public void MoveNext()
    {
        string result = null;
        try
        {
            if (_state == -1)
            {
                _client = new HttpClient();
                Task<string> task = _client.GetStringAsync("https://example.com");
                _awaiter = task.GetAwaiter();
                if (!_awaiter.IsCompleted)
                {
                    _state = 0;
                    _builder.AwaitUnsafeOnCompleted(ref _awaiter, ref this);
                    return;
                }
            }
            if (_state == 0)
            {
                result = _awaiter.GetResult();
            }
        }
        catch (Exception ex)
        {
            _state = -2;
            _builder.SetException(ex);
            return;
        }

        _state = -2;
        _builder.SetResult(result);
    }

    public void SetStateMachine(IAsyncStateMachine stateMachine)
    {
        _builder.SetStateMachine(stateMachine);
    }
}
```

- Переменные: Включает переменные для хранения состояния _state, построителя задач _builder, клиента _client и ожидающего _awaiter.
- Метод MoveNext: Управляет переходами между состояниями.
  - Состояние -1: Начальное состояние. Создает HttpClient, отправляет запрос и получает TaskAwaiter.
  - Проверка завершенности: Если задача еще не завершена, сохраняет текущее состояние (_state = 0) и возвращается. Когда задача завершится, MoveNext будет вызван снова.
  - Состояние 0: Задача завершена. Получает результат из awaiter.
- Обработка исключений: Ловит исключения, возникающие во время выполнения, и передает их в AsyncTaskMethodBuilder.
- Установка результата: Когда работа завершена, устанавливает результат задачи или исключение.

# ORM

Object-relational mapping (ORM) - это технология, позволяющая запрашивать и обрабатывать данные из базы данных с использованием объектно-ориентированной парадигмы.

Использование ORM решает проблему парадигмы «несоответствия», которая гласит о том, что объектные и реляционные модели не очень хорошо работают вместе. Реляционные базы представляют данные в табличном формате, в то время как объектно-ориентированные языки представляют их как связанный граф объектов.

## В чем преимущества ORM?

- Работа с СУБД в объектно-ориентированном стиле.
- DRY: Через ORM модель проще обновлять, поддерживать и повторно использовать.
- Многий функционал доступен с "коробки", в отличие от написания запросов собственноручно.
- В большинстве случаев вам не нужно писать SQL запросы.
- ORM очень хорошо подходит для ООП языков.

## В чем недостатки ORM?

- Сложнее трейсить ошибки и сами sql запросы, чем прямой вызов процедур.
- Потенциально ORM может не оптимально формировать SQL запросы, что будет влиять на производительность запросов.
- ORM зачастую работает медленее, чем SQL Stored Procedures или даже прямые запросы в базу.
- Порог входа может быть выше, если на проекте используется не популярная ORM.
 
## Когда ее лучше не использовать

- Когдау вас нет никаких связей 1-to-1, 1-to-many или many-to-many, нет особо смысла использовать ORM.
- Если ваша база данных будет иметь хранимые процедуры в качестве интерфейса, нет особого смысла использовать ORM.

## В чем разница между IQueryable и IEnumerable при работе с Entity Framework?

Основное отличие между этими интерфейсами в том, что IEnumerable работает со всем массивом данных, а IQueryable с отфильтрованным. IEnumerable получает все данные на стороне сервера и загружает их в память, а затем позволяет сделать фильтрацию по данным из памяти. Когда делается запрос к базе данных, IQueryable выполняет запрос на серверной стороне и в запросе применяет фильтрацию.

- IEnumerable хорошо подходит для работы с данными в памяти (списки, массивы).
- IQueryable лучше работает с запросами к базе данных.
- IQueryable поддерживает произвольные запросы (используя CreateQuery и метод Execute). IEnumerable не поддерживает произвольные запросы.
- IQueryable поддерживает отложенное выполнение (Lazy Evaluation). 
- Extension methods, работающие с IQueryable принимают объекты выражения (expression tree).
- Extension methods, работающие с IEnumerable принимают функциональные объекты.

## В чем разница между Eager loading и Lazy Loading в EF?

- Eager loading позволяет указать в запросе какие связанные данные нужно загрузить при выполнении запроса. EF будет транслировать Include() в JOIN, таким образом будет выполнен всего 1 запрос к БД.
- Lazy loading предполагает неявную автоматическую загрузку связанных данных при обращении к навигационному свойству.
- Lazy Loading может сильно притормаживать при определенных условиях. Так же вызывать n+1 проблему при попытке выполнения дополнительных запросов.

## Какие компоненты архитектуры Entity Framework вы знаете?

- Entity Data Model
- LINQ to Entities
- Entity SQL
- Object Service
- Entity Client data provider
- ADO.Net Data Provider

## Из чего состоит Entity Data Model (EDM)?

- Conceptual Model 
  - Концептуальная модель содержит классы модели (т.е. сущности) и их взаимосвязи. Это будет независимо от дизайна таблиц вашей базы данных. Она определяет ваши бизнес-объекты и их взаимосвязи в XML-файлах.
- Mapping Model
  - Модель отображения (Mapping Model) состоит из информации о том, как концептуальная модель сопоставляется с моделью хранения. Модель отображения отвечает за сопоставление концептуального и логического уровней (уровня хранения). Она сопоставляет бизнес-объекты и отношения, определенные на концептуальном уровне, с таблицами и отношениями, определенными на логическом уровне..
- Storage Model
  - Модель хранения представляет схему базы данных. Это означает, что модель хранения является моделью проектирования базы данных, которая включает таблицы, представления, ключи, хранимые процедуры и их взаимосвязи. Модель данных сущностей (Entity Data Model) использует следующие три типа XML-файлов для представления C-Space, C-S Space и S-Space соответственно.

## Какие 3 подхода для организации взаимодействия Entity Framework с базой данных существуют?

- Code-First
- Model-First - вы начинаете с создания модели в дизайнере EDMX. Entity Framework генерирует код и базу данных на основе этой модели.
- Database-First

## Какие Entity States поддерживаются в Entity Framework?

- Added
- Deleted
- Modified
- UnChanged 
  - Состояние Unchanged указывает на то, что сущность загружена из базы данных и с тех пор не изменялась. Это означает, что EF не видит никаких изменений в свойствах этой сущности, и при вызове SaveChanges() никаких обновлений для этой сущности не будет отправлено в базу данных.`
- Detached
  - Состояние Detached указывает на то, что сущность не отслеживается контекстом EF. Это может произойти по нескольким причинам:
    - Сущность была создана в коде, но еще не добавлена в контекст.
    - Сущность была удалена из контекста вручную.
    - Сущность была загружена без отслеживания.
    - Когда сущность находится в состоянии Detached, она не будет включена в процесс отслеживания изменений, и при вызове SaveChanges() EF не будет отправлять никаких изменений для этой сущности в базу данных.

## Что такое миграция и как ее выполнить в Entity Framework?

- Миграция позволяет вносить изменения в базу данных при изменениях моделей и контекста данных. Она автоматически обновляет схему базы данных при изменении вашей модели без потери существующих данных или других объектов базы данных.
- Есть два вида миграции: автоматическая миграция, и миграция на основе кода.

## Как можно хэндлить проблемы с параллелизмом в Entity Framework?

Это можно с помощью включения оптимистической блокировки с помощью следующего кода:

```csharp
modelBuilder.Entity<Author>()
.Property(a => a.RowVersion)
.IsConcurrencyToken()
.ValueGeneratedOnAddOrUpdate();
```

## Какие существуют типы наследования в Entity Framework?

Наследование в Entity Framework аналогично наследованию классов в C #. В Entity Framework вы можете смапить иерархию наследования с одной или несколькими таблицами базы данных в зависимости от ваших задач.

EF поддерживает три типа наследования:
- Table-per-Hierarchy (TPH)
- Table-per-Type (TPT)
- Table-per-Concrete-Type (TPC)  (не поддерживается в EF Core)

## EF Core поддерживает транзакции?

- Каждый раз, когда вы вызываете SaveChanges() для вставки, обновления или удаления данных в базе данных, эта операция оборачивается в транзакцию. Таким образом, вам не нужно явно открывать транзакции.
- Так же вы можете обернуть блок кода в транзакцию с помощью конструкции using var transaction = context.Database.BeginTransaction(); Для того чтобы закоммитить транзакцию, потом нужно выполнить transaction.Commit();

# AMQP?

AMQP (Advanced Message Queuing Protocol) — это открытый стандартный протокол для передачи сообщений между различными компонентами в распределенных системах. AMQP обеспечивает надежную, гарантированную доставку сообщений и поддерживает различные шаблоны обмена сообщениями. Основные характеристики AMQP включают:

- Надежность: AMQP обеспечивает гарантированную доставку сообщений, подтверждения доставки и обработку сообщений в случае ошибок.
- Интероперабельность: Позволяет разным системам и приложениям взаимодействовать друг с другом независимо от используемых технологий.
- Асинхронность: Поддержка асинхронного обмена сообщениями, что позволяет системам работать независимо и повышает масштабируемость.

AMQP широко используется в системах обмена сообщениями, таких как RabbitMQ, Apache Qpid и других.

Различия между Queue и Topic в AMQP
В AMQP сущности Queue (очередь) и Topic (тема) используются для разных типов обмена сообщениями и имеют свои особенности:

## Queue (Очередь)

- Что это? Очередь — это сущность, в которую сообщения помещаются и из которой они извлекаются.
- Использование: Очереди предназначены для point-to-point (точка-точка) передачи сообщений. Сообщение, помещенное в очередь, доставляется одному потребителю, который его извлекает.
- Модель потребления: Каждое сообщение читается и удаляется одним потребителем.
- Пример использования: Очереди идеально подходят для задач, где сообщение должно быть обработано только одним потребителем, например, обработка задач или заказов.

## Topic (Тема)

- Что это? Тема — это механизм публикации-рассылки (publish-subscribe), где сообщения публикуются и доставляются множеству подписчиков.
- Использование: Тема предназначена для передачи сообщений от одного издателя к нескольким подписчикам. Сообщение, опубликованное в тему, доставляется всем подписчикам этой темы.
- Модель потребления: Каждое сообщение доставляется всем подписчикам темы, которые активны на момент публикации сообщения.
- Пример использования: Тема подходит для задач, где сообщение должно быть доставлено множеству потребителей, например, рассылка уведомлений или публикация событий.

| Характеристика         | Queue (Очередь)                         | Topic (Тема)                              |
| ---------------------- | --------------------------------------- | ----------------------------------------- |
| **Модель**             | Point-to-Point                          | Publish-Subscribe                         |
| **Потребители**        | Одному потребителю                      | Множеству подписчиков                     |
| **Удаление сообщения** | После получения потребителем            | Не удаляется, передается всем подписчикам |
| **Использование**      | Обработка задач, распределение нагрузки | Рассылка уведомлений, событий             |

## Что такое Exchanges в протоколе AMQP

Exchanges в протоколе AMQP
В протоколе AMQP (Advanced Message Queuing Protocol) Exchange (обменник) — это компонент, который принимает сообщения от издателей и направляет их в соответствующие очереди на основе различных правил маршрутизации. Exchange играет ключевую роль в процессе маршрутизации сообщений в системе обмена сообщениями.

## Типы Exchanges (Direct, Fanout, Topic, Headers) и зачем они нужны?

- Direct Exchange
  - Описание: Сообщения направляются в очереди на основе точного соответствия ключа маршрутизации (routing key).
  - Использование: Подходит для одноадресной маршрутизации, когда необходимо доставить сообщение в одну конкретную очередь.
  - Пример: Если ключ маршрутизации сообщения и ключ маршрутизации очереди совпадают, сообщение направляется в эту очередь.
- Fanout Exchange
  - Описание: Сообщения направляются во все очереди, привязанные к этому обменнику, независимо от ключа маршрутизации.
  - Использование: Подходит для широковещательной рассылки, когда сообщение нужно отправить всем связанным очередям.
  - Пример: Сообщение передается всем очередям, связанным с Fanout Exchange, игнорируя ключ маршрутизации.
Topic Exchange
- Описание: Сообщения направляются в очереди на основе шаблонного соответствия ключа маршрутизации, который может включать подстановочные символы.
  - Использование: Подходит для сложной маршрутизации, когда нужно доставить сообщение в зависимости от темы или категории.
  - Пример: Ключ маршрутизации news.sports может совпадать с шаблоном news.* или *.sports.
- Headers Exchange
  - Описание: Сообщения направляются в очереди на основе совпадения заголовков сообщения, а не ключа маршрутизации.
  - Использование: Подходит для сложной маршрутизации на основе различных атрибутов сообщения.
  - Пример: Сообщение с заголовком {type: 'pdf', format: 'A4'} направляется в очередь, связанная с этими заголовками.

Exchanges в AMQP играют ключевую роль в маршрутизации сообщений. Они принимают сообщения от издателей и направляют их в соответствующие очереди на основе правил маршрутизации. Понимание различных типов обменников (Direct, Fanout, Topic, Headers) позволяет эффективно настраивать маршрутизацию сообщений в системах обмена сообщениями.

## Жизненный цикл компонентов AMQP: Соединения, Подписки, Очереди и Exchanges

## 1. Соединения (Connections)
Соединение представляет собой TCP-соединение между клиентом и брокером сообщений (например, RabbitMQ).

- **Создание**: 
  - Клиент устанавливает TCP-соединение с брокером сообщений.
  - TCP-соединение устанавливается с использованием протокола AMQP.
  - После установления соединения клиент и сервер обмениваются информацией о версиях протокола и конфигурации.
  
- **Использование**:
  - Соединение используется для отправки и получения сообщений.
  - Через одно соединение можно создавать несколько каналов.

- **Закрытие**:
  - Соединение может быть закрыто клиентом или сервером.
  - При закрытии соединения все связанные каналы также закрываются.

## 2. Каналы (Channels)
Каналы представляют собой виртуальные соединения внутри одного физического TCP-соединения.

- **Создание**:
  - Каналы создаются на существующем соединении.
  - Каждый канал имеет свой идентификатор и используется для изоляции операций.

- **Использование**:
  - Каналы используются для выполнения всех операций по обмену сообщениями.
  - Клиенты могут открывать несколько каналов для параллельной обработки.

- **Закрытие**:
  - Канал можно закрыть, не закрывая основное соединение.
  - Закрытие канала освобождает все ресурсы, связанные с ним.

## 3. Exchanges (Обменники)
Exchanges принимают сообщения от издателей и направляют их в соответствующие очереди на основе правил маршрутизации.

- **Создание**:
  - Обменники создаются клиентом с указанием типа (Direct, Fanout, Topic, Headers) и опций (например, устойчивость).
  - Обменник может быть создан явно через API или автоматически при первом использовании.

- **Использование**:
  - Сообщения публикуются в обменники, которые затем маршрутизируют их в очереди на основе ключей маршрутизации и привязок.
  
- **Закрытие**:
  - Обменники могут быть удалены, если больше не нужны.
  - Удаление обменника не влияет на сообщения в очередях.

## 4. Очереди (Queues)
Очереди хранят сообщения до тех пор, пока их не извлекут потребители.

- **Создание**:
  - Очереди создаются клиентом с указанием параметров, таких как устойчивость, эксклюзивность и автоматическое удаление.
  - Очередь может быть создана явно через API или автоматически при первой привязке к обменнику.

- **Использование**:
  - Сообщения направляются в очереди на основе правил маршрутизации.
  - Потребители извлекают сообщения из очередей для обработки.
  
- **Закрытие**:
  - Очередь может быть удалена, если больше не нужна.
  - При удалении очереди все содержащиеся в ней сообщения также удаляются.


## Что такое партиция в Kafka

Партиция в Apache Kafka — это основной механизм, с помощью которого достигается масштабируемость и параллелизм обработки данных. Партиции позволяют распределять данные и нагрузку между различными узлами и процессами, обеспечивая более высокую производительность и отказоустойчивость.

Основные характеристики партиций:
- Линейная структура: Каждая партиция представляет собой упорядоченный, неизменяемый лог сообщений, к которым добавляются новые сообщения. Сообщения в партиции идентифицируются по смещениям (offset), которые являются уникальными и последовательными.
- Распределение нагрузки: Данные, отправляемые в топик, распределяются по партициям. Это позволяет разделить нагрузку между несколькими брокерами и потребителями. Например, если у топика 4 партиции, то данные могут храниться и обрабатываться четырьмя различными брокерами.
- Параллельная обработка: Потребители могут обрабатывать сообщения параллельно, читая данные из различных партиций одновременно. Это значительно увеличивает производительность системы.
- Отказоустойчивость и репликация: Для повышения надежности каждая партиция может иметь несколько реплик, которые распределены по различным брокерам. Одна из реплик является лидером и отвечает за все операции записи и чтения, в то время как остальные реплики являются последователями и синхронизируются с лидером. Если лидер выходит из строя, один из последователей становится новым лидером.

```mathematica
orders
├── Partition 0
│   ├── Offset 0: {"order_id": 1, "product": "book"}
│   ├── Offset 1: {"order_id": 4, "product": "pen"}
│   └── ...
├── Partition 1
│   ├── Offset 0: {"order_id": 2, "product": "laptop"}
│   ├── Offset 1: {"order_id": 5, "product": "notebook"}
│   └── ...
├── Partition 2
    ├── Offset 0: {"order_id": 3, "product": "phone"}
    ├── Offset 1: {"order_id": 6, "product": "tablet"}
    └── ...
```

## В чем отличие Kafka от Service Bus или другого брокера сообщений?

Не смотря на то, что кафку юзают как систему для обмена сообщениями, у нее нет концепции очередей, ее называют commit log.

- Kafka – Это распределенный журнал фиксации изменений, по скольку там развертывается кластер узлов, как для устойчивости к ошибкам, так и для масштабирования.
- Реплицированный, поскольку сообщения обычно реплицируются на нескольких узлах (серверах).
- Журнал фиксации изменений, потому что сообщения хранятся в сегментированных, append-only log'ах, которые называются разделами (topic). Эта концепция является уникальной особенностью кафки.
- Каждая партиция в кафке предоставляет собой файл. Который гарантирует очередность сообщений в рамках одной партиции.

# Микросервисы

## Какие способы коммуникации между микросервисами вы знаете?​

- HTTP call
- Message Broker (AMQP)
- SignalR (Web sockets)
- gRPC 

## Как реализовать атомарность транзакции между несколькими микросервисами?

- Saga pattern + eventual consistency
- MassTransit + Saga
- Correlation id + обеспечение атомарности с помощью меседж брокера. По сути разновидность самописной саги.

## Какие способы хостинга микросервисов вы знаете?

- Docker + k8s
- Azure API Managment 

# Тестирование

## Какие вспомогательные библиотеки вы знаете и использовали для написания тестов?

- FluentAssertions
- Moq
- NSubstitute

## В чем разница между Integration и Unit тестами?

- Интеграционный тест показывает какой конкретно функционал не работает (регистрация, покупка товара и тд), но при этом не покажет конкретное место модуля где проблема. С этим поможет юнит тест, по-этому важно иметь хорошее покрытие юнит тестами, но в случае когда система большая, а тестами покрывать все нет времени, интеграционные тесты могут быть выходом, пока все не будет покрыто unit тестами.

## В чем разница между Dummy, Fake, Stubs, Spies, Mocks объектами?

- Stubs — предоставляют стандартные ответы на вызовы, сделанные во время теста, обычно не отвечая ни на что, кроме того, что запрограммировано для теста.
  - Основное назначение: Предоставление данных для теста.
  - Контроль: Stub не проверяет, какие методы вызываются или с какими параметрами.
  - Применение: Stub используется, когда вам нужно заменить реальный объект на нечто, что возвращает фиксированные данные для теста.
- Mocks — объекты, заранее запрограммированные с ожиданиями, которые формируют спецификацию вызовов, которые они ожидают получить. Проверки соответствия ожиданиям проводятся 
через вызовы к Mock-объекту.
  - Основное назначение: Проверка взаимодействий (вызовов методов и их параметров).
  - Контроль: Mock может проверять, какие методы были вызваны и с какими параметрами, а также сколько раз они были вызваны.
  - Применение: Mock используется, когда вам нужно не только заменить реальный объект, но и убедиться, что методы этого объекта вызываются ожидаемым образом.
- Dummy — это объекты, которые передаются в методы, но на самом деле не используются. В основном, это параметры методов (если конечно, они не влияют в тесте на то, что мы хотим проверить). Иногда это просто NULL
- Fake — объекты, которые имеют внутреннюю реализацию, но обычно она сильно урезанная и их нельзя использовать в продакшине. Memory database хороший пример Fake объекта.
- Spies — это Stubs, которые также записывают некоторую информацию в зависимости от того, как они были вызваны. Одной из форм этого может быть сервис электронной почты, который записывает, сколько сообщений было отправлено.

# Как написать интеграционный тест в ASP.NET Core?

📚​ Ресурс для изучения: [Интеграционные тесты в ASP.NET Core](https://bool.dev/blog/detail/integratsionnye-testy-v-aspnet-core-prilozhenii)

Для этого подойдет класс TestServer


# Сетевое взаимодействие и протоколы

## HTTP

## Структура HTTP-сообщения

### HTTP-запрос

1. **Стартовая строка (Request Line)**:
    - **Метод**: указывает действие, которое клиент хочет выполнить (например, GET, POST).
    - **URI (Uniform Resource Identifier)**: указывает ресурс, к которому обращается клиент.
    - **Версия протокола**: указывает версию HTTP (например, HTTP/1.1).

    Пример:
    ```
    GET /index.html HTTP/1.1
    ```

2. **Заголовки (Headers)**: содержат метаинформацию о запросе и клиенте.
    Пример:
    ```
    Host: www.example.com
    User-Agent: Mozilla/5.0
    ```

3. **Тело (Body)**: содержит данные, передаваемые на сервер (используется в методах, таких как POST или PUT).
    Пример:
    ```
    { "username": "user", "password": "pass" }
    ```

### HTTP-ответ

1. **Стартовая строка (Status Line)**:
    - **Версия протокола**: указывает версию HTTP (например, HTTP/1.1).
    - **Код состояния (Status Code)**: указывает результат запроса (например, 200, 404).
    - **Сообщение состояния (Status Message)**: текстовое описание кода состояния.

    Пример:
    ```
    HTTP/1.1 200 OK
    ```

2. **Заголовки (Headers)**: содержат метаинформацию об ответе и сервере.
    Пример:
    ```
    Content-Type: text/html
    Content-Length: 1234
    ```

3. **Тело (Body)**: содержит данные, передаваемые клиенту (например, HTML-страница, JSON-данные).
    Пример:
    ```
    <html><body>Hello, World!</body></html>
    ```

## Классы кодов состояния HTTP

### 1xx (Информационные)
- **100 Continue**: Сервер получил начальную часть запроса и клиент может продолжать.
- **101 Switching Protocols**: Сервер принимает запрос клиента на переключение протоколов.

### 2xx (Успешные)
- **200 OK**: Запрос успешно обработан.
- **201 Created**: Запрос успешно выполнен и ресурс создан.
- **204 No Content**: Запрос успешно выполнен, но тело ответа пустое.

### 3xx (Перенаправления)
- **301 Moved Permanently**: Ресурс перемещен на постоянное новое место.
- **302 Found**: Ресурс временно доступен по другому URL.
- **304 Not Modified**: Ресурс не изменялся, можно использовать кэшированную версию.

### 4xx (Ошибки клиента)
- **400 Bad Request**: Неверный запрос клиента.
- **401 Unauthorized**: Требуется аутентификация.
- **403 Forbidden**: Доступ к ресурсу запрещен.
- **404 Not Found**: Ресурс не найден.

### 5xx (Ошибки сервера)
- **500 Internal Server Error**: Внутренняя ошибка сервера.
- **502 Bad Gateway**: Сервер, действующий как шлюз, получил некорректный ответ.
- **503 Service Unavailable**: Сервер временно недоступен.

## Методы HTTP

### GET
- **Описание**: Запрашивает представление ресурса. Данные передаются через URL.
- **Применение**: Получение данных, таких как HTML-страницы или JSON-объекты.
- **Пример**: `GET /users/1`

### POST
- **Описание**: Отправляет данные на сервер для создания/обновления ресурса.
- **Применение**: Создание новых записей, отправка форм.
- **Пример**: `POST /users` с телом запроса `{ "name": "John", "age": 30 }`

### PUT
- **Описание**: Отправляет данные на сервер для создания/обновления ресурса. Обычно используется для обновления существующих ресурсов.
- **Применение**: Обновление записей.
- **Пример**: `PUT /users/1` с телом запроса `{ "name": "John", "age": 31 }`

### DELETE
- **Описание**: Удаляет указанный ресурс.
- **Применение**: Удаление записей.
- **Пример**: `DELETE /users/1`

### OPTIONS
- **Описание**: Запрашивает поддерживаемые методы для ресурса.
- **Применение**: Определение доступных операций для ресурса.
- **Пример**: `OPTIONS /users`

## WebSockets

## Каковы особенности веб-сокетов?

Веб-сокет обеспечивает two-way communication через одно TCP-соединение.
С помощью него возможна Read-Time коммуникация между веб серверами и клиентами

## Какие основные Web Socket API events?

- Open
- Close
- Error
- Message

## Что такое Short polling и Long polling?

- Short polling - это техника, когда клиент проверяет сервер повторно, например, каждые 500 мс.
- Long polling - сервер получает запрос, но не отвечает на него, пока не получит новые данные из другого запроса.Как это работает? 
  - Запрос отправляется на сервер.
  - Сервер не закрывает соединение, пока у него не возникнет сообщение для ответа.
  - Когда появляется сообщение – сервер отвечает на запрос, отправляя ответ.
  - Браузер немедленно делает новый запрос.

## Что такое CORS? 

- Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент.
- Для инициации Cross-origin запроса браузер клиента добавляет в HTTP запрос Origin (домен сайта, с которого происходит запрос). Например, страница http://www.a.com/page.html пытается получить данные со страницы http://www.b.com/cors.txt. 
- За проверку CORS заголовков отвечает браузер. Именно он отклоняет запрос, если он не прошел CORS политики.
- Политики проверяются с помощью OPTIONS запроса.

## Что такое OAuth?

OAuth (Open Authorization) – это открытый стандарт аутентификации и авторизации на основе токенов. OAuth позволяет third-party сервисам таким как Facebook, использовать информацию учетной записи конечного пользователя, не раскрывая пароль пользователя.

## JWT token

JWT-токен состоит из трех частей: Header, Payload, Signature. Они разделяются точкой.

- Header - объект JSON, который содержит информацию о типе токена и алгоритме его шифрования
- Payload - объект JSON, который содержит данные, нужные для авторизации пользователя
- Signature - строка, которая создается с помощью secret'а, Header'a и Payload'a. Эта строка служит для верификации токена

## Как инвалидировать JWT токен в ASP.NET?

- Если нас взломали или нам срочно нужно сделать невалидными токены юзеров мы можем поменять secret который валидирует токены, это гарантирует, что старые токены перестанут работать у всех юзеров
- Refresh token + короткое время жизни токена. Этот способ также позволит управлять этим процессом и добавить доп проверку на этапе рефреш токена, для определенных юзеров.
- Более топорный способ это повесить глобальный фильтр который будет проверять специфических юзеров за критерием и отсеивать их.

## Что такое middleware в ASP.NET Core?

В ASP.NET Core middleware – это классы C#, которые могут обрабатывать HTTP-request'ы и respons'ы. middleware умеет:

- Захэндлить входящий HTTP-запрос путем создания HTTP-ответа.
- Обработать HTTP-запрос, изменить его и передать другой middleware на обработку.
- Обработать исходящий HTTP-ответ, изменить его и передать либо другому middleware, либо веб-серверу ASP.NET Core.

middleware можно разделить на такие типы:
- Content-Generating Middleware - Для отправки ответа прямо внутри middleware. Такие middleware никогда не переходят к следующей по цепочке.
- Short-Circuiting Middleware – так называют middleware, которые не всегда переходит к следующей Middleware, а по какому-то условию возвращают ответ прямо внутри себя. 
- Request-Editing Middleware – так называют middleware, в которых нам нужно отредактировать запрос.
- Response-Editing Middleware –  так называют middleware, в которых нам нужно отредактировать ответ.

В чем разница между app.Use и app.Run при добавлении middleware?
- app.Use позволяет вызывать следующую middleware в pipeline
- app.Run не вызывает следующую по списку middleware 
- app.Run также не принимает на вход параметр next

## Что такое SignalR, как он работает?

- SignalR - это абстракция над соединением. Это дает вам две модели программирования через это соединение (хабы и persistent коннекшины)
- SignalR имеет несколько встроенных "транспортов":
  - WebSockets
  - Server Sent Events
  - Forever Frame
  - Long polling
- WebSocket - единственный транспорт, который устанавливает настоящее двустороннее persistent соединение между клиентом и сервером. Однако WebSocket поддерживается только IIS 8 или выше, а также современными версиями Internet Explorer, Google Chrome и Mozilla Firefox.
- В то время как Server Sent Events, Forever Frame и Long polling, все три работают по one-way коннекшину и поддерживаются большинством браузеров.

## В чем разница между ConfigureServices и Configure в ASP.NET Core?

- ConfigureServices – мы используем тогда, когда нам нужно добавить сервисы и использовать их через интегрированный DI, как пример мы можем добавить EntityFramework в ConfigureServices и юзать его в дальнейшем инджектя через конструктор.
- Configure – мы используем для настройки middleware. По сути мы управляем HTTP реквест пайплайном внутри configure метода.

## В чем разница между services.AddTransient, service.AddScoped и service.AddSingleton в встроеном DI ASP.NET Core?

- Transient: при каждом обращении к сервису создается новый объект сервиса. Т.е если в рамках одного реквеста у вас будет несколько обращений к сервису, он будет создан несколько раз 
- Scoped: для каждого запроса создается свой объект сервиса. То есть если в течение одного запроса есть несколько обращений к одному сервису, то при всех этих обращениях будет использоваться один и тот же объект сервиса.
- Singleton: объект сервиса создается при первом обращении к нему, все последующие запросы используют один и тот же ранее созданный объект сервиса

Dependency injection антипаттерны:
- ​Control Freak
- Bastard Injection
- Constrained Construction
- Service Locator

# Какие типы фильтров существуют в ASP.NET Core?

Фильтры позволяют выполнять некоторые действия до или после определенной стадии обработки запроса. В ASP.NET Core имеются следующие типы фильтров:

- Фильтры авторизации: определяют, авторизован ли пользователь для выполнения текущего запроса. Если пользователь не авторизованн для доступа к ресурсу, то фильтр завершает обработку запроса.
- Фильтры ресурсов: выполняются после фильтров авторизации. Его метод OnResourceExecuting() выполняется до всех остальных фильтров и до привязки модели, а его метод OnResourceExecuted() выполняется после всех остальных фильтров
- Фильтры действий: применяется только к действиям контроллера, запускается после фильтра ресурсов как до, так и после выполнения метода контроллера
- Фильтры RazorPages: применяется только к страницам RazorPages, выполняются перед и после обработки запроса страницей Razor Page
- Фильтры исключений: определяют действия в отношении необработанных исключений
- Фильтры результатов действий: фильтр применяется к результатам методов контроллера и страниц Razor Pages, выполняется как до, так и после получения результата


# Базы данных

## **Уровни изоляции транзакций SQL**

Уровни изоляции транзакций в SQL регулируют степень видимости изменений, сделанных одной транзакцией, для других транзакций. Они определяют, какие побочные эффекты (такие как грязные чтения, неповторимые чтения и фантомные чтения) могут возникнуть при параллельном выполнении транзакций. В SQL существует четыре основных уровня изоляции:

## Аномалии параллельного выполнения транзакций в SQL

В контексте уровней изоляции транзакций в SQL термины "грязные чтения", "неповторимые чтения" и "фантомные чтения" относятся к возможным аномалиям при параллельном выполнении транзакций. Вот их объяснение:

## Грязные чтения (Dirty Read)

- **Описание**: Транзакция может прочитать данные, которые были изменены другой транзакцией, но еще не зафиксированы (т.е. могут быть откатаны). Это означает, что одна транзакция читает промежуточное состояние данных другой транзакции.
- **Пример**: Транзакция A обновляет значение записи, но еще не фиксирует изменения. Транзакция B читает это обновленное значение. Если транзакция A откатывается, данные, прочитанные транзакцией B, становятся некорректными.

## Неповторимые чтения (Non-repeatable Read)

- **Описание**: Транзакция читает одно и то же значение дважды, но между этими двумя чтениями другая транзакция изменяет (обновляет или удаляет) это значение. В результате, при повторном чтении данных, транзакция видит измененные значения.
- **Пример**: Транзакция A читает значение записи. Транзакция B затем обновляет это значение и фиксирует изменения. Если транзакция A снова читает это значение, оно будет отличаться от первоначально прочитанного.

## Фантомные чтения (Phantom Read)

- **Описание**: Транзакция повторно выполняет запрос, который ранее вернул определенный набор строк, но в промежутке другая транзакция вставляет или удаляет строки, изменяя набор данных, возвращаемый запросом. В результате, второй запрос возвращает другой набор строк.
- **Пример**: Транзакция A выполняет запрос на выборку всех записей, соответствующих определенному условию. Транзакция B затем вставляет новую запись, которая удовлетворяет этому условию, и фиксирует изменения. Когда транзакция A повторно выполняет тот же запрос, она видит дополнительную строку (фантом).

Эти аномалии являются ключевыми при выборе уровня изоляции транзакций, поскольку разные уровни изоляции предотвращают разные комбинации этих аномалий.


## Read Uncommitted (Чтение незафиксированных данных)

- **Описание**: Транзакции могут читать данные, которые еще не зафиксированы другими транзакциями.
- **Побочные эффекты**: Возможны грязные чтения (Dirty Read), неповторимые чтения (Non-repeatable Read) и фантомные чтения (Phantom Read).
- **Использование**: Этот уровень изоляции редко используется из-за риска получения неконсистентных данных.

## Read Committed (Чтение зафиксированных данных)

- **Описание**: Транзакции могут читать только те данные, которые уже зафиксированы другими транзакциями.
- **Побочные эффекты**: Исключает грязные чтения, но возможны неповторимые чтения и фантомные чтения.
- **Использование**: Это наиболее распространенный уровень изоляции, обеспечивающий баланс между производительностью и согласованностью данных.

## Repeatable Read (Повторяемое чтение)

- **Описание**: Гарантирует, что данные, прочитанные в транзакции, не изменятся до завершения транзакции. Транзакции не могут видеть изменения, сделанные другими транзакциями после первого чтения.
- **Побочные эффекты**: Исключает грязные и неповторимые чтения, но возможны фантомные чтения.
- **Использование**: Используется в ситуациях, где важно, чтобы данные, прочитанные в начале транзакции, оставались неизменными до её завершения.

## Serializable (Сериализуемость)

- **Описание**: Обеспечивает наивысший уровень изоляции. Транзакции выполняются так, как если бы они были последовательно выполнены одна за другой, а не параллельно.
- **Побочные эффекты**: Исключает грязные, неповторимые и фантомные чтения.
- **Использование**: Используется в критически важных системах, где требуется полная изоляция транзакций. Однако этот уровень изоляции может значительно снизить производительность системы из-за высокой блокировки ресурсов.

## Таблица сравнения уровней изоляции

| Уровень изоляции | Грязные чтения | Неповторимые чтения | Фантомные чтения |
| ---------------- | -------------- | ------------------- | ---------------- |
| Read Uncommitted | Да             | Да                  | Да               |
| Read Committed   | Нет            | Да                  | Да               |
| Repeatable Read  | Нет            | Нет                 | Да               |
| Serializable     | Нет            | Нет                 | Нет              |

Эти уровни изоляции помогают разработчикам выбирать наиболее подходящий уровень контроля параллелизма для их конкретных приложений, обеспечивая баланс между производительностью и целостностью данных.

---

## Нормальные формы в реляционных базах данных

Нормальные формы используются для структурирования баз данных для уменьшения избыточности данных и обеспечения их целостности. Существует несколько нормальных форм, каждая из которых предъявляет свои требования к структуре таблиц.

## Первая нормальная форма (1NF)

- **Требование**: Все значения атрибутов должны быть атомарными, а все записи в таблице должны быть уникальными.
- **Пример**:

| StudentID | StudentName | Subjects      |
| --------- | ----------- | ------------- |
| 1         | Alice       | Math, English |
| 2         | Bob         | Science, Art  |

Преобразуется в:

| StudentID | StudentName | Subject |
| --------- | ----------- | ------- |
| 1         | Alice       | Math    |
| 1         | Alice       | English |
| 2         | Bob         | Science |
| 2         | Bob         | Art     |

## Вторая нормальная форма (2NF)

- **Требование**: Должна удовлетворять 1NF и каждый неключевой атрибут должен полностью зависеть от первичного ключа.
- **Пример**:

| OrderID | ProductID | ProductName | Quantity |
| ------- | --------- | ----------- | -------- |
| 1       | 101       | Widget A    | 5        |
| 2       | 102       | Widget B    | 3        |

Преобразуется в две таблицы:

Таблица Orders:

| OrderID | ProductID | Quantity |
| ------- | --------- | -------- |
| 1       | 101       | 5        |
| 2       | 102       | 3        |

Таблица Products:

| ProductID | ProductName |
| --------- | ----------- |
| 101       | Widget A    |
| 102       | Widget B    |

## Третья нормальная форма (3NF)

- **Требование**: Должна удовлетворять 2NF и никакой неключевой атрибут не должен зависеть от другого неключевого атрибута (отсутствие транзитивных зависимостей).
- **Пример**:

| EmployeeID | EmployeeName | DepartmentID | DepartmentName |
| ---------- | ------------ | ------------ | -------------- |
| 1          | John         | 10           | HR             |
| 2          | Jane         | 20           | IT             |

Преобразуется в две таблицы:

Таблица Employees:

| EmployeeID | EmployeeName | DepartmentID |
| ---------- | ------------ | ------------ |
| 1          | John         | 10           |
| 2          | Jane         | 20           |

Таблица Departments:

| DepartmentID | DepartmentName |
| ------------ | -------------- |
| 10           | HR             |
| 20           | IT             |

## Бойс-Кодд нормальная форма (BCNF)

- **Требование**: Должна удовлетворять 3NF и для каждого непустого отношения \(R\), если \(X \rightarrow Y\) (функциональная зависимость), то \(X\) является суперключом.
- **Пример**:

| StudentID | CourseID | Instructor |
| --------- | -------- | ---------- |
| 1         | 101      | Dr. Smith  |
| 2         | 101      | Dr. Smith  |

Преобразуется в две таблицы:

Таблица StudentsCourses:

| StudentID | CourseID |
| --------- | -------- |
| 1         | 101      |
| 2         | 101      |

Таблица CoursesInstructors:

| CourseID | Instructor |
| -------- | ---------- |
| 101      | Dr. Smith  |

## Четвёртая нормальная форма (4NF)

- **Требование**: Должна удовлетворять BCNF и не должна содержать многозначных зависимостей.
- **Пример**:

| StudentID | Course  | Hobby   |
| --------- | ------- | ------- |
| 1         | Math    | Chess   |
| 1         | Science | Chess   |
| 1         | Math    | Reading |
| 2         | Art     | Reading |

Преобразуется в две таблицы:

Таблица StudentsCourses:

| StudentID | Course  |
| --------- | ------- |
| 1         | Math    |
| 1         | Science |
| 2         | Art     |

Таблица StudentsHobbies:

| StudentID | Hobby   |
| --------- | ------- |
| 1         | Chess   |
| 1         | Reading |
| 2         | Reading |

## Пятая нормальная форма (5NF)

- **Описание**: Таблица находится в пятой нормальной форме, если она находится в 4NF и не содержит соединительных зависимостей, которые не могут быть декомпозированы без потери данных.
- **Пример**:

    | ProjectID | TaskID | EmployeeID |
    | --------- | ------ | ---------- |
    | 1         | 101    | 1001       |
    | 1         | 102    | 1002       |
    | 2         | 103    | 1001       |

    Преобразование в 5NF:
    
    Таблица ProjectTask:
  
    | ProjectID | TaskID |
    | --------- | ------ |
    | 1         | 101    |
    | 1         | 102    |
    | 2         | 103    |

    Таблица TaskEmployee:
  
    | TaskID | EmployeeID |
    | ------ | ---------- |
    | 101    | 1001       |
    | 102    | 1002       |
    | 103    | 1001       |

## Шестая нормальная форма (6NF)

- **Описание**: Таблица находится в шестой нормальной форме, если она удовлетворяет условиям 5NF и не содержит нетривиальных соединений между зависимостями атрибутов.
- **Пример**:
    - Таблица 6NF слишком специализирована и редко используется на практике, обычно в случаях, когда требуется очень высокая степень нормализации для обеспечения полной гибкости данных.

Эти примеры показывают, как данные могут быть организованы для минимизации избыточности и обеспечения целостности на различных уровнях нормализации.

---

## Что такое cte в SQL, какие usecases для cte вы знаете?

Common Table Expression — общие табличные выражения, их еще называют конструкциями с WITH. Фактически это создание временных таблиц, но существующих только для одного запроса, а не для сессии.
CTE можно использовать для рекурсивных вызовов

# Материализация выражений при использовании CTE (Common Table Expressions)

## Pros (Преимущества)

1. **Улучшение читаемости и структурирования кода**:
   - CTE позволяют разбить сложные запросы на более мелкие и управляемые части, делая код более понятным.
   - Пример:
     ```sql
     WITH EmployeeCTE AS (
         SELECT EmployeeID, FirstName, LastName
         FROM Employees
         WHERE DepartmentID = 1
     )
     SELECT *
     FROM EmployeeCTE
     WHERE LastName LIKE 'S%';
     ```

2. **Рекурсивные запросы**:
   - CTE поддерживают рекурсию, что позволяет выполнять задачи, такие как обработка иерархий или графов.
   - Пример:
     ```sql
     WITH RECURSIVE EmployeeHierarchy AS (
         SELECT EmployeeID, ManagerID, 1 AS Level
         FROM Employees
         WHERE ManagerID IS NULL
         UNION ALL
         SELECT e.EmployeeID, e.ManagerID, eh.Level + 1
         FROM Employees e
         JOIN EmployeeHierarchy eh ON e.ManagerID = eh.EmployeeID
     )
     SELECT * FROM EmployeeHierarchy;
     ```

3. **Материализация данных**:
   - В некоторых системах CTE могут материализоваться (записывать результат промежуточного выражения), что может улучшить производительность при повторном использовании результатов.

## Cons (Недостатки)

1. **Временные таблицы**:
   - CTE по своей природе являются временными и существуют только в пределах одного запроса, что ограничивает их повторное использование в разных запросах.
   
2. **Производительность**:
   - В некоторых случаях CTE могут приводить к ухудшению производительности, если оптимизатор запросов неэффективно их обрабатывает.
   - Материализация данных может потребовать дополнительных ресурсов (памяти и процессорного времени).

# Разница между View и CTE

## View

- **Описание**: Представление (View) — это сохраненный запрос, который можно использовать как таблицу.
- **Сохранение**: View сохраняется в базе данных и может быть переиспользовано в разных запросах.
- **Материализация**: Представления обычно не материализуются; каждый раз, когда они используются, выполняется запрос, который их определяет.
- **Использование**:
  - Создание представления:
    ```sql
    CREATE VIEW EmployeeView AS
    SELECT EmployeeID, FirstName, LastName
    FROM Employees
    WHERE DepartmentID = 1;
    ```
  - Использование представления:
    ```sql
    SELECT * FROM EmployeeView
    WHERE LastName LIKE 'S%';
    ```

## CTE (Common Table Expression)

- **Описание**: CTE — это временное результирующее множество, определенное в пределах одного запроса.
- **Временность**: CTE существует только на время выполнения запроса и не сохраняется в базе данных.
- **Материализация**: Некоторые CTE могут материализоваться в зависимости от системы и запроса, что может улучшить или ухудшить производительность.
- **Использование**:
  - Определение и использование CTE:
    ```sql
    WITH EmployeeCTE AS (
        SELECT EmployeeID, FirstName, LastName
        FROM Employees
        WHERE DepartmentID = 1
    )
    SELECT * FROM EmployeeCTE
    WHERE LastName LIKE 'S%';
    ```

## Сравнение

| Характеристика              | View                            | CTE                          |
| --------------------------- | ------------------------------- | ---------------------------- |
| **Сохранение**              | Постоянное                      | Временное                    |
| **Повторное использование** | Да                              | Нет                          |
| **Материализация**          | Обычно не материализуется       | Может материализоваться      |
| **Область видимости**       | Глобальная в рамках базы данных | Локальная в пределах запроса |
| **Поддержка рекурсии**      | Нет                             | Да                           |

Эти различия помогают выбрать наиболее подходящий инструмент в зависимости от конкретной задачи и требований производительности.

## В чем разница между WHERE и HAVING в SQL?

WHERE используется движком на момент выборки, а HAVING работает уже с сгруппироваными строками. К примеру если нам нужно выбрать юзеров где минимальное значение после группировки 3, нам нужно использовать HAVING, Если же нам нужно отсеять юзеров значение колонки которых  равно или больше/меньше чего-то, то тут будем использовать WHERE

---

## ACID & CAP

# Концепции ACID и CAP

## ACID

ACID — это набор свойств, гарантирующих надежность транзакций в реляционных базах данных. Эти свойства обеспечивают целостность данных даже в случае сбоев системы или других ошибок.

### Расшифровка ACID:

1. **Atomicity (Атомарность)**:
   - **Описание**: Транзакция должна быть атомарной, т.е. либо все её операции выполняются успешно, либо ни одна из них не выполняется. Если одна из операций не может быть выполнена, вся транзакция откатывается.
   - **Пример**: При переводе денег между счетами, если деньги списаны с одного счета, но не зачислены на другой, вся транзакция откатывается.

2. **Consistency (Согласованность)**:
   - **Описание**: Транзакция должна переводить базу данных из одного согласованного состояния в другое. После завершения транзакции все правила и ограничения базы данных должны быть соблюдены.
   - **Пример**: В базе данных банка, после транзакции, сумма денег на всех счетах должна соответствовать бизнес-правилам.

3. **Isolation (Изоляция)**:
   - **Описание**: Одновременные транзакции не должны мешать друг другу. Промежуточные состояния транзакции не должны быть видимы другим транзакциям.
   - **Пример**: Если две транзакции выполняются одновременно, одна из них не должна видеть промежуточные изменения другой.

4. **Durability (Долговечность)**:
   - **Описание**: После завершения транзакции её изменения должны быть сохранены в системе даже в случае сбоя.
   - **Пример**: Если транзакция по переводу денег завершена, данные должны быть сохранены и не потеряны даже при отключении питания.

## CAP Theorem (Теорема CAP)

CAP — это теорема в распределенных системах, предложенная Эриком Брюером. Она утверждает, что невозможно одновременно достичь всех трех свойств в распределенной системе. Системы должны выбирать два из трех свойств.

### Расшифровка CAP:

1. **Consistency (Согласованность)**:
   - **Описание**: Все узлы системы видят одни и те же данные в одно и то же время. Это означает, что после выполнения операции записи все последующие операции чтения будут видеть результат этой записи.
   - **Пример**: В банковской системе, если деньги переведены с одного счета на другой, все пользователи должны видеть обновленный баланс сразу после завершения транзакции.

2. **Availability (Доступность)**:
   - **Описание**: Каждое запрос получает ответ (успешный или неуспешный), даже если некоторые узлы системы недоступны.
   - **Пример**: Веб-сайт продолжает отвечать на запросы пользователей, даже если несколько серверов вышли из строя.

3. **Partition Tolerance (Устойчивость к разделению)**:
   - **Описание**: Система продолжает работать, несмотря на произвольное разделение сети, из-за которого узлы не могут общаться друг с другом.
   - **Пример**: В случае сбоя сети, разделившего систему на две части, каждая часть продолжает работать независимо.

### Выбор двух из трех свойств

- В реальных распределенных системах приходится делать выбор в пользу двух из трех свойств, поскольку достижение всех трех одновременно невозможно.
- **CP (Consistency + Partition Tolerance)**:
  - **Описание**: Система гарантирует согласованность данных и устойчивость к разделению, но может быть недоступна при разделении сети.
  - **Пример**: Системы баз данных, такие как HBase.
- **AP (Availability + Partition Tolerance)**:
  - **Описание**: Система гарантирует доступность и устойчивость к разделению, но данные могут быть не согласованными.
  - **Пример**: Системы баз данных, такие как Cassandra.
- **CA (Consistency + Availability)**:
  - **Описание**: Система гарантирует согласованность и доступность, но не устойчива к разделению.
  - **Пример**: Системы, работающие в условиях отсутствия разделений сети (это теоретическая возможность, поскольку реальное распределение данных всегда предполагает возможность разделений).

Эти концепции помогают понимать, как организованы и функционируют базы данных и распределенные системы, а также позволяют принимать обоснованные решения при проектировании архитектуры систем.

## Разница между Optimistic и Pessimistic Lock

## Optimistic Lock (Оптимистическая блокировка)

### Описание
- **Оптимистическая блокировка** предполагает, что конфликтов при доступе к данным будет мало или они не произойдут вообще. Поэтому транзакции работают с копией данных и проверяют конфликт только при записи.
- **Механизм**: При чтении данных транзакция запоминает версию (или временную метку) данных. При записи данных транзакция проверяет, изменилась ли версия данных с момента чтения. Если данные изменились, транзакция повторяется или откатывается.
- **Использование**: Подходит для сценариев, где ожидается низкая вероятность конфликтов при записи, таких как веб-приложения с высокой степенью параллелизма.

### Пример
```sql
-- Предположим, что у нас есть таблица Products с колонкой Version для отслеживания версии
BEGIN TRANSACTION;

-- Чтение данных с сохранением версии
SELECT ProductID, Quantity, Version
FROM Products
WHERE ProductID = 1;

-- Попытка обновления данных
UPDATE Products
SET Quantity = 20, Version = Version + 1
WHERE ProductID = 1 AND Version = @original_version;

IF @@ROWCOUNT = 0
BEGIN
    -- Конфликт: версия изменилась, нужно повторить транзакцию
    ROLLBACK TRANSACTION;
    -- Повторить операцию чтения и обновления
END
ELSE
BEGIN
    -- Успех: данные обновлены
    COMMIT TRANSACTION;
END
```

### Преимущества
- Высокая производительность при редких конфликтах.
- Меньшая задержка в операциях чтения.

### Недостатки
- Необходимость повторного выполнения транзакций при обнаружении конфликта.
- Сложность реализации логики проверки версий.

## Pessimistic Lock (Пессимистическая блокировка)

### Описание
- **Пессимистическая блокировка** предполагает, что конфликты при доступе к данным вероятны. Поэтому транзакции блокируют данные для предотвращения изменений другими транзакциями до завершения работы.
- **Механизм**: При чтении или изменении данных транзакция устанавливает блокировку, которая предотвращает другие транзакции от чтения или записи тех же данных до освобождения блокировки.
- **Использование**: Подходит для сценариев с высокой вероятностью конфликтов, таких как системы управления запасами, банковские системы.

### Пример

```sql
-- Предположим, что у нас есть таблица Products
BEGIN TRANSACTION;

-- Установка блокировки при чтении данных
SELECT ProductID, Quantity
FROM Products WITH (UPDLOCK)
WHERE ProductID = 1;

-- Обновление данных
UPDATE Products
SET Quantity = 20
WHERE ProductID = 1;

COMMIT TRANSACTION;
```

### Преимущества
- Предотвращение конфликтов за счет блокировки данных.
- Гарантия согласованности данных.

### Недостатки
- Высокая вероятность взаимоблокировок (deadlocks).
- Уменьшение параллелизма и, как следствие, производительности.
- Долгие блокировки могут снижать доступность данных.

---

## Индексы в SQL

# Разница между кластерным и некластерным индексами

## Кластерный индекс

### Описание
- **Кластерный индекс** определяет физическое упорядочение данных в таблице. В таблице может быть только один кластерный индекс, так как данные могут быть упорядочены только одним способом.
- **Структура**: Данные таблицы хранятся на страницах в порядке, определенном кластерным индексом. Каждая таблица с кластерным индексом называется кластеризованной таблицей.
- Пример
  ```sql
  CREATE TABLE Employees (
      EmployeeID INT PRIMARY KEY,
      LastName NVARCHAR(50),
      FirstName NVARCHAR(50),
      DepartmentID INT
  );
  ```

В данном примере EmployeeID является кластерным индексом.
  - Преимущества
    - Быстрый доступ к данным, так как данные физически упорядочены по индексу.
    - Эффективное выполнение диапазонных запросов.
  - Недостатки
    - При вставке, обновлении и удалении данных может возникать фрагментация, что замедляет операции.
    - Ограничение на один кластерный индекс на таблицу.

## Некластерный индекс

### Описание
- **Некластерный индекс** не изменяет физическое упорядочение данных в таблице. Вместо этого он создает отдельную структуру, которая указывает на местоположение данных.
- Структура: Некластерный индекс содержит ключи индекса и указатели на соответствующие строки данных.
- Пример
  ```sql
  CREATE NONCLUSTERED INDEX IX_Employees_LastName
  ON Employees (LastName);
  ```

  В данном примере LastName является некластерным индексом.

  - Преимущества
    - Можно создать несколько некластерных индексов на таблице.
    - Улучшает производительность запросов, которые не охватываются кластерным индексом.
  - Недостатки
    - Занимает дополнительное пространство в базе данных.
    - Влияет на производительность операций вставки, обновления и удаления, так как индексы должны обновляться.

### Типы некластерных индексов

- **Составной индекс**
  - Описание: Индекс, который создается на нескольких столбцах таблицы.
  - Пример:
    ```sql
    CREATE NONCLUSTERED INDEX IX_Employees_LastName_FirstName
    ON Employees (LastName, FirstName);
    ```
  - Преимущества: Улучшает производительность запросов, которые фильтруют данные по обоим столбцам.

- **Уникальный индекс**
  - Описание: Некластерный индекс, который гарантирует уникальность значений в индексируемых столбцах.
  - Пример:
    ```sql
    CREATE UNIQUE NONCLUSTERED INDEX IX_Employees_Email
    ON Employees (Email);
    ```
  - Преимущества: Обеспечивает уникальность данных в столбцах и ускоряет поиск.

- **Покрывающий индекс**
  - Описание: Некластерный индекс, который содержит все столбцы, необходимые для выполнения конкретного запроса.
  - Пример:
    ```sql
    CREATE NONCLUSTERED INDEX IX_Employees_Covering
    ON Employees (LastName)
    INCLUDE (FirstName, DepartmentID);
    ```
  - Преимущества: Значительно улучшает производительность запросов, так как вся необходимая информация для запроса находится в индексе, и нет необходимости обращаться к основной таблице.

## **Как индексы облегчают поиск ?**

## Облегчение поиска с помощью индексов

Индексы облегчают поиск в базе данных за счет создания дополнительных структур данных, которые позволяют быстро находить нужные записи. Основные способы, которыми индексы ускоряют поиск:

1. **Бинарный поиск**:
   - Индексы организованы в структуру данных, такую как B-дерево или хеш-таблица, которая позволяет выполнять бинарный поиск. Это значительно быстрее, чем последовательный просмотр всех записей в таблице.
   - **Пример**: В упорядоченном массиве из 1000 элементов бинарный поиск потребует в худшем случае всего 10 сравнений, тогда как линейный поиск может потребовать до 1000 сравнений.

2. **Упорядоченность данных**:
   - Кластерные индексы физически упорядочивают данные в таблице, что ускоряет выполнение диапазонных запросов (например, поиск всех записей между двумя значениями).
   - **Пример**: Запрос `SELECT * FROM Employees WHERE LastName BETWEEN 'A' AND 'M'` будет выполняться быстрее, если данные упорядочены по `LastName`.

3. **Ссылки на данные**:
   - Некластерные индексы содержат ссылки на физическое местоположение данных в таблице, что позволяет быстро находить нужные строки без необходимости последовательного просмотра всей таблицы.
   - **Пример**: Некластерный индекс на `LastName` позволяет мгновенно найти строку с определенной фамилией без необходимости просмотра всех записей.

4. **Покрывающие индексы**:
   - Покрывающие индексы содержат все данные, необходимые для выполнения запроса, что позволяет извлекать данные прямо из индекса без обращения к основной таблице.
   - **Пример**: Запрос `SELECT LastName, FirstName FROM Employees WHERE DepartmentID = 5` будет быстрее, если существует покрывающий индекс на `LastName, FirstName` и `DepartmentID`.

## Минусы индексов

Хотя индексы могут значительно улучшить производительность запросов, они также имеют свои недостатки:

1. **Дополнительное пространство**:
   - Индексы требуют дополнительного дискового пространства для хранения структуры данных индекса.
   - **Пример**: Таблица с несколькими индексами может занимать значительно больше места, чем таблица без индексов.

2. **Замедление операций вставки, обновления и удаления**:
   - При вставке, обновлении или удалении данных все соответствующие индексы должны быть обновлены, что может замедлить эти операции.
   - **Пример**: Обновление значения в столбце, по которому построен индекс, потребует обновления индекса, что увеличит время выполнения операции.

3. **Фрагментация данных**:
   - Со временем индексы могут стать фрагментированными, что приводит к снижению производительности запросов и требует периодической реорганизации или перестроения индексов.
   - **Пример**: Фрагментированный индекс может замедлить выполнение запросов, так как данные будут разбросаны по разным страницам диска.

4. **Сложность управления**:
   - Управление индексами требует дополнительных усилий, включая анализ производительности, создание и удаление индексов, а также их обслуживание.
   - **Пример**: Неправильный выбор столбцов для индексирования может не улучшить, а ухудшить производительность системы.

## Заключение

Индексы являются мощным инструментом для улучшения производительности запросов в базах данных. Однако их использование должно быть тщательно продумано, чтобы избежать дополнительных затрат на пространство и замедление операций записи. Оптимальное использование индексов требует баланса между ускорением чтения данных и увеличением издержек на вставку, обновление и удаление данных.
