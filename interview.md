**Аспектно-ориентированное**

Аспектно-ориентированное програмирование базируется на изучении того сколько и каких компонент или частей требуется для взаимодействия с системой. Основным для АОП является взаимодействие этих элементов.

**Интерфейсно-ориентированное**

Интерфейсно-ориентированное программирование это подход основанный на программировании по контракту. Ни одна часть интерфейса не зависит от того как реализована другая, вся коммуникация между ними описана в контракте. Веб-сервисы на основе WSDL наиболее известный пример этого подхода.

**Объектно-ориентированное** 

Объектно-ориентированное программирование основывается на понятиях абстракции, инкапсуляции, полиморфизма и наследования. Классы реализуют эти концепции для построения объектов, контролирующих или реализующих систему.

* Абстракция позволяет уменьшить связывание между компонентами пердоставляя дополнительный слой между ними, для того чтоб один объект не зависил от того, как другой реализуюет свои бизнес-правила. (Интерфейсы, слои) Отличная штука, если вы хотите изолировать части системы так, чтоб их изменение или замена не стали проблеммой для работы системы в целом.
* Инкапсуляция позволяет работать абстракции пряча детали реализации класса от вызывающих его. (Публичные и приватные поля)
* Наследование позволяет базовым (родительским) классам содержать общую функциональность и передавать ее всем своим классам-потомкам. Класс Figure(фигура) может иметь поле цвет, которое будет унаследовано его классами-потомками Square(квадрат) или Circle(круг).
* Полиморфизм позволяет реализовывать одноименные публичные методы, позволяя различным классам выполнять различные действия при одном и том же вызове. То есть объекты классов Square и Circle могут отображаться(реализовывать метод render) поразному несмотря не то, что они оба подклассы Shape, метод render определен в Shape. (Overriding)

 ---

**Что такое CLR? Что такое IL? Что такое CLS?**

* CLR ("Common Language Runtime", "общеязыковая исполняющая среда") - это компонент .NET Framework, основной задачей которого является управление интерпретацией и исполнением кода IL. CLR отвечает за изоляцию памяти приложений, проверку типов, безопасность кода, преобразование IL в машинный код.
* IL (Intermediate Language) - код, содержащий набор инструкций, не зависящих от платформы. Иными словами, после компиляции исходного кода он преобразуется не в код для какой-то определенной платформы, а в промежуточный код на языке IL.
* CLS ("Common Language Specification", общеязыковая спецификация) - это набор правил, следуя которым разработчики достигают бесконфликтной работы во всех языках .NET.

**Какая наименьшая исполнимая единица в .NET?**

сборка

---
# **Память**

**Что такое managed code?**

Управляемый код (managed code) - это код, работающий в среде CLR. Содержит метаданные, в которых находится информация для среды выполнения - о типах, членах и ссылках, используемых в коде.

**Что такое managed и unmanaged resources в .NET?**

Managed ресурсы – это ресурсы для очистки которых используется Garbage collector.

Unmanaged ресурсы – ресурсы которые не очищаются сборщиком мусора и их нужно явно очищать после выполнения кода, который их использовал, например: работа с файлом, работа с бд и тд.

Ситуации, когда мы работаем с неуправляемыми ресурсами:
* Работа с файловыми операциями на низком уровне
* Сетевые операции и сокеты
* Базы данных и соединения
* Вызов функций из неуправляемых библиотек с использованием платформозависимого вызова (P/Invoke)
* Работа с графическими ресурсами
* Работа с COM-объектами

Интероперабельность — это способность различных систем и компонентов взаимодействовать и обмениваться информацией. В контексте программного обеспечения и систем, интероперабельность позволяет компонентам, написанным на разных языках программирования и работающим на разных платформах, корректно взаимодействовать друг с другом.

**В чем различие между Value Type и Reference Type?**

Value Type находятся в стеке, а Reference Type в куче.

## Garbage Collector - start

Статьи:
* https://habr.com/ru/companies/clrium/articles/464169
* https://learn.microsoft.com/ru-ru/dotnet/standard/garbage-collection/large-object-heap


## Фазы сборки мусора

- **Маркировка (mark phase)**:
  Во время этого этапа CLR должна найти все живые объекты. Собирая мусор в эфемерных поколениях, сборщик должен получить у среды исполнения информацию о том, какие объекты в этих поколениях по-прежнему используются программой.

- **Чистка (sweep phase)**:
  На этом этапе моделируется сжатие, чтобы определить его эффективность. Если результат оказывается продуктивным, сборщик начинает фактическое сжатие. В противном случае он просто производит уборку.

- **Сжатие (compact phase)**:
  Если сборщик выполняет сжатие, это приводит к перемещению объектов, и необходимо обновить ссылки на эти объекты. Во время этапа перемещения сборщик должен найти все ссылки, указывающие на объекты в тех поколениях, где проводится сборка мусора. При сжатии объекты будут скопированы по новым адресам, определенным во время этапа планирования.

## Описание работы

Сборщик делит объекты на две категории: маленькие (< 85 000 байт) и большие (>= 85 000 байт). Разделение по размеру происходит, поскольку сжатие больших объектов требует много ресурсов.

После сборки объектов в поколении **N**, оставшиеся объекты маркируются как принадлежащие поколению **N+1**. Этот процесс называется продвижением объектов по поколениям. Существуют исключения, когда необходимо перевести объект в поколение ниже или не продвигать его вообще.

Сборка поколения означает сборку объектов в этом поколении, а также во всех его более молодых поколениях. Сборка мусора поколения 2 также называется полной сборкой мусора.

Пользовательский код может размещать объекты только в поколении **0 (маленькие объекты)** или в куче больших объектов (большие объекты). Только GC может "выделить" объекты в поколении 1 (путем поощрения выживших из поколения 0) и поколения 2 (путем поощрения выживших из поколения 1).

## Этапы сборки мусора

- **Этап маркировки**:
  CLR должна найти все живые объекты. Сборщик должен получить информацию о том, какие объекты в этих поколениях по-прежнему используются программой.

- **Этап планирования**:
  Моделируется сжатие, чтобы определить его эффективность. Если результат продуктивный, сборщик начинает сжатие. В противном случае он просто производит уборку.

- **Этап перемещения**:
  Если сборщик выполняет сжатие, это приводит к перемещению объектов и обновлению ссылок на них.

- **Этап сжатия**:
  Объекты копируются по новым адресам, определенным на этапе планирования.

## Память и сегменты

- **Сегменты**:
  Управляемая куча состоит из набора сегментов – непрерывных блоков памяти, переданных сборщику мусора ОС. Сегменты делятся на мелкие и большие участки для размещения маленьких и больших объектов.

- **Память по времени жизни**:
  Память делится, исходя из времени жизни её элементов. Сегмент кучи заполняется от младших адресов к старшим. 

## Поколения

- **Маленькие объекты**:
  Поколения gen0, gen1 и gen2.

- **Большие объекты**:
  Одно поколение – gen3.

## Дополнительные вопросы и ответы

**Когда объект удаляется сборщиком мусора?**
> Объект удаляется сборщиком мусора, когда на него не остается ссылок.

**Зачем нужен метод DisposeAsync() который добавили в C# 8?**
> DisposeAsync позволяет выполнять ресурсоемкую операцию удаления, не блокируя основной поток приложения графического пользовательского интерфейса в течение длительного времени.

**В чем различие между Finalize и Dispose?**
> Dispose обеспечивает **явный** контроль над ресурсами, используемыми объектом, а Finalize **неявный**, используемый сборщиком мусора.

**Dispose(), Finalize() – что это за методы, как используются в .NET?**
> Используются для освобождения ресурсов. Применяя метод Dispose, вы должны обеспечить неявную очистку методом Finalize. Если программисту не удалось вызвать метод Dispose, использование метода Finalize предотвращает постоянную утечку ресурсов.

### Пример кода

```csharp
public class ResourceHandler : IDisposable
{
    // Управляемый ресурс
    private FileStream managedResource;

    // Неуправляемый ресурс
    private IntPtr unmanagedResource;

    private bool disposed = false;

    // Константы для вызова CreateFile
    private const uint GENERIC_READ = 0x80000000;
    private const uint GENERIC_WRITE = 0x40000000;
    private const uint OPEN_EXISTING = 3;
    private const uint FILE_ATTRIBUTE_NORMAL = 0x80;

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr CreateFile(
        string lpFileName,
        uint dwDesiredAccess,
        uint dwShareMode,
        IntPtr lpSecurityAttributes,
        uint dwCreationDisposition,
        uint dwFlagsAndAttributes,
        IntPtr hTemplateFile);

    [DllImport("kernel32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool CloseHandle(IntPtr hObject);

    public ResourceHandler(string filePath)
    {
        // Инициализация управляемого ресурса
        managedResource = new FileStream(filePath, FileMode.OpenOrCreate);

        // Инициализация неуправляемого ресурса с использованием CreateFile
        unmanagedResource = CreateFile(
            filePath,
            GENERIC_READ | GENERIC_WRITE,
            0,
            IntPtr.Zero,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            IntPtr.Zero);

        if (unmanagedResource == IntPtr.Zero)
        {
            throw new IOException("Unable to open file.", Marshal.GetLastWin32Error());
        }
    }

    // Деструктор
    ~ResourceHandler()
    {
        Dispose(false);
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!disposed)
        {
            if (disposing)
            {
                // Освобождение управляемых ресурсов
                if (managedResource != null)
                {
                    managedResource.Dispose();
                    managedResource = null;
                }
            }

            // Освобождение неуправляемых ресурсов
            if (unmanagedResource != IntPtr.Zero)
            {
                CloseHandle(unmanagedResource);
                unmanagedResource = IntPtr.Zero;
            }

            disposed = true;
        }
    }
}
```

Блок if (disposing) в методе Dispose(bool disposing) используется исключительно для освобождения управляемых ресурсов.

Финализатор (деструктор):
Вызывает Dispose(false) для освобождения только неуправляемых ресурсов, если метод Dispose не был вызван явно.

Метод Dispose:
Явный вызов этого метода освобождает как управляемые, так и неуправляемые ресурсы, а затем вызывает GC.SuppressFinalize(this), чтобы предотвратить вызов финализатора.

> Метод GC.SuppressFinalize(this) используется для предотвращения вызова метода Finalize для объекта. Это полезно, когда объект уже освободил свои ресурсы и вызов Finalize больше не требуется.

Метод Dispose(bool disposing):
Если disposing равно true, освобождаются как управляемые (managedResource), так и неуправляемые ресурсы (unmanagedResource).
Если disposing равно false, это означает, что метод был вызван из финализатора, и освобождаются только неуправляемые ресурсы, так как управляемые ресурсы могли быть уже финализированы сборщиком мусора.

**Для чего в .NET используется конструкция using(…){…}? Причем тут IDisposable?**
Значение Using непосредственно связано с интерфейсом IDisposable. Интерфейс IDisposable представляет нам возможность быстро освободить общие ресурсы, не полагаясь на автоматический сборщик мусора (garbage collector). Конструкция Using позволяет вызывать метод Dispose автоматически, как только нужный объект выйдет за блок Using.

```csharp
using (var resource = new Resource("example.txt"))
        {
            resource.Write("Hello, World!");
        }
        
        // Эквивалентный код без использования using
        var anotherResource = new Resource("another_example.txt");
        try
        {
            anotherResource.Write("Hello, Universe!");
        }
        finally
        {
            if (anotherResource != null)
            {
                anotherResource.Dispose();
            }
        }
```

**GC.Collect()**

Метод GC.Collect() инициирует сборку мусора вручную. Обычно GC работает автоматически, но иногда может потребоваться явный вызов GC.Collect(), например, для тестирования или в критических ситуациях с управлением памятью.

```csharp
GC.Collect();
```

Использование этого метода следует ограничить, так как частые вызовы могут негативно сказаться на производительности приложения из-за высоких накладных расходов на сборку мусора.

## Garbage Collector - end


**Что такое Boxing и Unboxing?**

Упаковка (boxing) позволяет преобразовать ***значимый*** тип в ***ссылочный***. При упаковке объекта значимого типа происходят следующие действия:

* Выделяется память в управляемой куче.
* Совершается копирование полей размерного типа в память, которая была выделена в куче.
* Возвращается адрес объекта.

Процесс извлечения адреса полей из упакованного объекта называется распаковкой (unboxing). Распаковка не является полной противоположностью упаковке. В отличие от упаковки при распаковке не происходит никакого копирования. Однако обычно вслед за распаковкой следует копирование полей, поэтому обе операции (распаковка и копирование) являются противоположностью операции упаковки.

Упаковка и распаковка/копирование снижают производительность приложения как в плане замедления, так и в расходе дополнительной памяти, поэтому нужно стараться минимизировать создание кода, в котором происходят операции упаковки и распаковки/копирования.

Когда может потребоваться использование упаковки и распаковки:

* Методы, принимающие параметры типа object: Если метод принимает параметр типа object, передача значения типа-значения приведет к упаковке.
* Полиморфизм: При использовании полиморфизма, когда метод работает с типом object, чтобы обеспечить работу с любыми типами данных
* Работа с немодифицируемыми API: Иногда приходится работать с API, которые требуют типы object, даже если у вас есть значение типа-значения.
* Интерфейсы: При передаче значений типов-значений методам, которые принимают интерфейсные типы, реализуемые этими значениями, происходит упаковка.

Предположим, у нас есть интерфейс ***IPrintable*** и структура ***Point***, ***реализующая*** этот интерфейс. Когда мы передаем экземпляр ***Point*** в ***метод***, который ***принимает параметр типа IPrintable***, происходит ***упаковка***.

**В чем различие между классом и структурой?**

Для С# классы System.Object, System.Exception, System.File-Stream и System.Random — это ссылочные типы (память выделяется из упр. кучи).
В свою очередь размерные (значимые) типы в документации называются структурами (structure) и перечислениями (enumeration). Например, структуры System.Int32, System.Boolean, System.Decimal, System.TimeSpan и перечисления System.DayOfWeek, System.10.FileAttributes и System.Drawing.FontStyle являются размерными типами (хранятся обычно в стеке потока, но могут быть встроены в ссылочные типы).

> TBD

---

# Делегаты, события

**Чем отличается event от delegate?**

Delegate – это по сути указатель на функцию.

В С# модель издатель — подписчик, где класс публикует событие, которое он может инициировать, и любые классы могут подписаться на это событие. Метод, вызываемый при возникновении события, определяется делегатом.

---

# Модификаторы доступа

* public: Доступен всем.
* private: Доступен только внутри своего класса.
* protected: Доступен внутри своего класса и производных классов.
* internal: Доступен только внутри текущей сборки.
* protected internal: Доступен внутри текущей сборки и производных классов.
* private protected: Доступен внутри текущего класса и производных классов в той же сборке.

---

**Что обозначает термин immutable (неизменяемый)?**

Это значит, что данные, хранящиеся в переменной, не могут быть изменены. При этом заметьте, что значение переменной может быть изменено - путём отказа от использования старых данных, которые могут быть изменены. Оригинальные данные остаются в памяти, а новые значения создаются вновь, в новой области памяти. Пример тип String.

**Какая разница между классами System.String и System.Text.StringBuilder?**

***Данные, хранящиеся в классе System.String и есть неизменяемые (immutable)***. Класс System.StringBuilder разрабатывался так, чтобы над изменяемой строкой можно было проделать множество операций. То есть при каждой операции над объектом класса System.String происходит перенос данных в новую область памяти, что влияет на производительность программы.

**Какое преимущество использования класса System.Text.StringBuilder перед System.String?**

Класс StringBuilder более эффективен в случае работы с большим количеством строк. Объекты класса System.String неизменяемы, поэтому при каждом изменении строки создаётся новый объект в памяти.

---

# Массивы

**Объясните разницу между System.Array.CopyTo() и System.Array.Clone()?**

Первая операция осуществляет глубокое копирование массива, а вторая – поверхностное. Поверхностное копирование массива копирует только сами элементы объекта класса Array, независимо от того являются они ссылочными или значимыми типами. Копирования объектов, на которые ссылаются ссылочные типы не происходит. Ссылки в новом объекте класса Array указывают на те же объекты, что и ссылки в оригинальном массиве Array. Глубокое копирование копирует как элементы класса Array, так и объекты, на которые они явно или неявно ссылаются.

---

# Приведение типов

**as, is – что это, как применяется?**

С помощью оператора ***as*** программа пытается преобразовать выражение к определенному типу, при этом не выбрасывает исключение. В случае неудачного преобразования выражение будет содержать значение null.

---

**В чем разница между throw ex; и throw;?**

***throw*** повторно выбрасывает исключение (***re-throw***), которое было обнаружено, и сохраняет трассировку стека (путь к источнику исключения).
***throw ex*** генерирует одно и то же исключение, но сбрасывает трассировку стека на метод, где делается ***throw ex***.

**Как работает return в try-catch-finally?**

Алгоритм приблизительно такой:

* Выполняется код перед оператором return;
* Выражение в return оценивается
* Выполняется finally блок
* Возвращается результат, посчитанный на шаге 2

---

# Классы

## Назовите класс .NET, от которого наследуются все классы?

System.Object.

## В каком случае вы обязаны объявить класс абстрактным?

В том случае, если класс является наследником абстрактного класса, но не все методы базового класса перекрыты и имеют реализацию.
В том случае, если хотя бы один метод класса является абстрактным

## Как работает Equals в C#?

В классе System.Object есть все несколько методов, один из них ReferenceEquals

Стоить отметить, что == и RefefenceEquals работает идентично, сравнивая ссылки на объекты в куче

```csharp
 public static bool Equals(Object objA, Object objB) 
    {
        if (objA==objB) {
            return true;
        }
        if (objA==null || objB==null) {
            return false;
        }
        return objA.Equals(objB);
    }
```

**Сравнение Value типов через Equals**

* Проверяет можно ли сделать побитовое сравнение, если да, то выполняется FastEqualsCheck(Object a, Object b);
* Если же это не побитовое сравнение, применяется рефлексия, и значения всех полей сравниваются попарно через Equals(object).

> Если структура содержит поля, которые являются ссылочными типами, следует переопределить метод Equals(Object). Это может повысить производительность и позволить более точно представить значение равенства для типа. Так как при большом количестве полей, выполнение ValueType.Equals может быть очень затратным по времени. При переопределении так же не забывайте переопределять и метод GetHashCode который используется в таких типах данных как Dictionary для сравнения объектов.

**IEqualityComparer**

Если вам нужен метод для сравнения объектов для конкретного типа, а не общей ситуации (или вы хотите сравнивать специальным образом объекты, которые вам не принадлежат), вы можете делегировать сравнение специальному объекту, реализующему интерфейс IEqualityComparer или типизированный IEqualityComparer<T>. Сравнение при помощи таких сравнивающих объектов применяют, например, Hashatable и Dictionary<K, V>, а также некоторые LINQ-методы.

К этому интерфейсу есть и его реализация с помощью EqualityComparer<T>. EqualityComparer<T>, он проверяет реализует ли объект интерфейс IEquatable<T>, и в противном случае выполняет сравнение через стандартный Equal(object). При реализации IEqualityComparer рекомендуется  наследоваться от EqualityComparer.

**IComparable**

Проверка на равенство так же может быть выполнена  через сравнение больше/меньше/равно. Для этого используются операторы сравнения </>, интерфейсы IComparable (аналог метода Equals(object)), IComparable<T> (аналог интерфейса IEquatable<T>)
