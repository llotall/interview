**Аспектно-ориентированное**

Аспектно-ориентированное програмирование базируется на изучении того сколько и каких компонент или частей требуется для взаимодействия с системой. Основным для АОП является взаимодействие этих элементов.

**Интерфейсно-ориентированное**

Интерфейсно-ориентированное программирование это подход основанный на программировании по контракту. Ни одна часть интерфейса не зависит от того как реализована другая, вся коммуникация между ними описана в контракте. Веб-сервисы на основе WSDL наиболее известный пример этого подхода.

**Объектно-ориентированное** 

Объектно-ориентированное программирование основывается на понятиях абстракции, инкапсуляции, полиморфизма и наследования. Классы реализуют эти концепции для построения объектов, контролирующих или реализующих систему.

* Абстракция позволяет уменьшить связывание между компонентами пердоставляя дополнительный слой между ними, для того чтоб один объект не зависил от того, как другой реализуюет свои бизнес-правила. (Интерфейсы, слои) Отличная штука, если вы хотите изолировать части системы так, чтоб их изменение или замена не стали проблеммой для работы системы в целом.
* Инкапсуляция позволяет работать абстракции пряча детали реализации класса от вызывающих его. (Публичные и приватные поля)
* Наследование позволяет базовым (родительским) классам содержать общую функциональность и передавать ее всем своим классам-потомкам.
* Полиморфизм позволяет реализовывать одноименные публичные методы, позволяя различным классам выполнять различные действия при одном и том же вызове. То есть объекты классов Square и Circle могут отображаться(реализовывать метод render) поразному несмотря не то, что они оба подклассы Shape, метод render определен в Shape. (Overriding)

 ---

**Что такое CLR? Что такое IL? Что такое CLS?**

* CLR ("Common Language Runtime", "общеязыковая исполняющая среда") - это компонент .NET Framework, основной задачей которого является управление интерпретацией и исполнением кода IL. CLR отвечает за изоляцию памяти приложений, проверку типов, безопасность кода, преобразование IL в машинный код.
* IL (Intermediate Language) - код, содержащий набор инструкций, не зависящих от платформы. Иными словами, после компиляции исходного кода он преобразуется не в код для какой-то определенной платформы, а в промежуточный код на языке IL.
* CLS ("Common Language Specification", общеязыковая спецификация) - это набор правил, следуя которым разработчики достигают бесконфликтной работы во всех языках .NET.

**Какая наименьшая исполнимая единица в .NET?**

сборка

---
# **Память**

**Что такое managed code?**

Управляемый код (managed code) - это код, работающий в среде CLR. Содержит метаданные, в которых находится информация для среды выполнения - о типах, членах и ссылках, используемых в коде.

**Что такое managed и unmanaged resources в .NET?**

Managed ресурсы – это ресурсы для очистки которых используется Garbage collector.

Unmanaged ресурсы – ресурсы которые не очищаются сборщиком мусора и их нужно явно очищать после выполнения кода, который их использовал, например: работа с файлом, работа с бд и тд.

Ситуации, когда мы работаем с неуправляемыми ресурсами:
* Работа с файловыми операциями на низком уровне
* Сетевые операции и сокеты
* Базы данных и соединения
* Вызов функций из неуправляемых библиотек с использованием платформозависимого вызова (P/Invoke)
* Работа с графическими ресурсами
* Работа с COM-объектами

Интероперабельность — это способность различных систем и компонентов взаимодействовать и обмениваться информацией. В контексте программного обеспечения и систем, интероперабельность позволяет компонентам, написанным на разных языках программирования и работающим на разных платформах, корректно взаимодействовать друг с другом.

**В чем различие между Value Type и Reference Type?**

Value Type находятся в стеке, а Reference Type в куче.

## Garbage Collector - start

Статьи:
* https://habr.com/ru/companies/clrium/articles/464169
* https://learn.microsoft.com/ru-ru/dotnet/standard/garbage-collection/large-object-heap


## Фазы сборки мусора

- **Маркировка (mark phase)**:
  Во время этого этапа CLR должна найти все живые объекты. Собирая мусор в эфемерных поколениях, сборщик должен получить у среды исполнения информацию о том, какие объекты в этих поколениях по-прежнему используются программой.

- **Чистка (sweep phase)**:
  На этом этапе моделируется сжатие, чтобы определить его эффективность. Если результат оказывается продуктивным, сборщик начинает фактическое сжатие. В противном случае он просто производит уборку.

- **Сжатие (compact phase)**:
  Если сборщик выполняет сжатие, это приводит к перемещению объектов, и необходимо обновить ссылки на эти объекты. Во время этапа перемещения сборщик должен найти все ссылки, указывающие на объекты в тех поколениях, где проводится сборка мусора. При сжатии объекты будут скопированы по новым адресам, определенным во время этапа планирования.

## Описание работы

Сборщик делит объекты на две категории: маленькие (< 85 000 байт) и большие (>= 85 000 байт). Разделение по размеру происходит, поскольку сжатие больших объектов требует много ресурсов.

После сборки объектов в поколении **N**, оставшиеся объекты маркируются как принадлежащие поколению **N+1**. Этот процесс называется продвижением объектов по поколениям. Существуют исключения, когда необходимо перевести объект в поколение ниже или не продвигать его вообще.

Сборка поколения означает сборку объектов в этом поколении, а также во всех его более молодых поколениях. Сборка мусора поколения 2 также называется полной сборкой мусора.

Пользовательский код может размещать объекты только в поколении **0 (маленькие объекты)** или в куче больших объектов **(большие объекты)**. Только GC может "выделить" объекты в поколении 1 (путем поощрения выживших из поколения 0) и поколения 2 (путем поощрения выживших из поколения 1).

## Этапы сборки мусора

- **Этап маркировки**:
  CLR должна найти все живые объекты. Сборщик должен получить информацию о том, какие объекты в этих поколениях по-прежнему используются программой.

- **Этап планирования**:
  Моделируется сжатие, чтобы определить его эффективность. Если результат продуктивный, сборщик начинает сжатие. В противном случае он просто производит уборку.

- **Этап перемещения**:
  Если сборщик выполняет сжатие, это приводит к перемещению объектов и обновлению ссылок на них.

- **Этап сжатия**:
  Объекты копируются по новым адресам, определенным на этапе планирования.

## Память и сегменты

- **Сегменты**:
  Управляемая куча состоит из набора сегментов – непрерывных блоков памяти, переданных сборщику мусора ОС. Сегменты делятся на мелкие и большие участки для размещения маленьких и больших объектов.

- **Память по времени жизни**:
  Память делится, исходя из времени жизни её элементов. Сегмент кучи заполняется от младших адресов к старшим. 

## Поколения

- **Маленькие объекты**:
  Поколения gen0, gen1.

- **Большие объекты**:
  Одно поколение – gen2.

## Дополнительные вопросы и ответы

**Когда объект удаляется сборщиком мусора?**

Объект удаляется сборщиком мусора, когда на него не остается ссылок.

**Зачем нужен метод DisposeAsync() который добавили в C# 8?**

DisposeAsync позволяет выполнять ресурсоемкую операцию удаления, не блокируя основной поток приложения графического пользовательского интерфейса в течение длительного времени.

**В чем различие между Finalize и Dispose?**

Dispose обеспечивает **явный** контроль над ресурсами, используемыми объектом, а Finalize **неявный**, используемый сборщиком мусора.

**Dispose(), Finalize() – что это за методы, как используются в .NET?**

Используются для освобождения ресурсов. Применяя метод Dispose, вы должны обеспечить неявную очистку методом Finalize. Если программисту не удалось вызвать метод Dispose, использование метода Finalize предотвращает постоянную утечку ресурсов.

### Пример кода

```csharp
public class ResourceHandler : IDisposable
{
    // Управляемый ресурс
    private FileStream managedResource;

    // Неуправляемый ресурс
    private IntPtr unmanagedResource;

    private bool disposed = false;

    // Константы для вызова CreateFile
    private const uint GENERIC_READ = 0x80000000;
    private const uint GENERIC_WRITE = 0x40000000;
    private const uint OPEN_EXISTING = 3;
    private const uint FILE_ATTRIBUTE_NORMAL = 0x80;

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr CreateFile(
        string lpFileName,
        uint dwDesiredAccess,
        uint dwShareMode,
        IntPtr lpSecurityAttributes,
        uint dwCreationDisposition,
        uint dwFlagsAndAttributes,
        IntPtr hTemplateFile);

    [DllImport("kernel32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool CloseHandle(IntPtr hObject);

    public ResourceHandler(string filePath)
    {
        // Инициализация управляемого ресурса
        managedResource = new FileStream(filePath, FileMode.OpenOrCreate);

        // Инициализация неуправляемого ресурса с использованием CreateFile
        unmanagedResource = CreateFile(
            filePath,
            GENERIC_READ | GENERIC_WRITE,
            0,
            IntPtr.Zero,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            IntPtr.Zero);

        if (unmanagedResource == IntPtr.Zero)
        {
            throw new IOException("Unable to open file.", Marshal.GetLastWin32Error());
        }
    }

    // Деструктор
    ~ResourceHandler()
    {
        Dispose(false);
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!disposed)
        {
            if (disposing)
            {
                // Освобождение управляемых ресурсов
                if (managedResource != null)
                {
                    managedResource.Dispose();
                    managedResource = null;
                }
            }

            // Освобождение неуправляемых ресурсов
            if (unmanagedResource != IntPtr.Zero)
            {
                CloseHandle(unmanagedResource);
                unmanagedResource = IntPtr.Zero;
            }

            disposed = true;
        }
    }
}
```

Блок if (disposing) в методе Dispose(bool disposing) используется исключительно для освобождения управляемых ресурсов.

Финализатор (деструктор):
Вызывает Dispose(false) для освобождения только неуправляемых ресурсов, если метод Dispose не был вызван явно.

Метод Dispose:
Явный вызов этого метода освобождает как управляемые, так и неуправляемые ресурсы, а затем вызывает GC.SuppressFinalize(this), чтобы предотвратить вызов финализатора.

Метод GC.SuppressFinalize(this) используется для предотвращения вызова метода Finalize для объекта. Это полезно, когда объект уже освободил свои ресурсы и вызов Finalize больше не требуется.

Метод Dispose(bool disposing):
Если disposing равно true, освобождаются как управляемые (managedResource), так и неуправляемые ресурсы (unmanagedResource).
Если disposing равно false, это означает, что метод был вызван из финализатора, и освобождаются только неуправляемые ресурсы, так как управляемые ресурсы могли быть уже финализированы сборщиком мусора.

**Для чего в .NET используется конструкция using(…){…}? Причем тут IDisposable?**
Значение Using непосредственно связано с интерфейсом IDisposable. Интерфейс IDisposable представляет нам возможность быстро освободить общие ресурсы, не полагаясь на автоматический сборщик мусора (garbage collector). Конструкция Using позволяет вызывать метод Dispose автоматически, как только нужный объект выйдет за блок Using.

```csharp
using (var resource = new Resource("example.txt"))
        {
            resource.Write("Hello, World!");
        }
        
        // Эквивалентный код без использования using
        var anotherResource = new Resource("another_example.txt");
        try
        {
            anotherResource.Write("Hello, Universe!");
        }
        finally
        {
            if (anotherResource != null)
            {
                anotherResource.Dispose();
            }
        }
```

**GC.Collect()**

Метод GC.Collect() инициирует сборку мусора вручную. Обычно GC работает автоматически, но иногда может потребоваться явный вызов GC.Collect(), например, для тестирования или в критических ситуациях с управлением памятью.

```csharp
GC.Collect();
```

Использование этого метода следует ограничить, так как частые вызовы могут негативно сказаться на производительности приложения из-за высоких накладных расходов на сборку мусора.

## Garbage Collector - end


**Что такое Boxing и Unboxing?**

Упаковка (boxing) позволяет преобразовать ***значимый*** тип в ***ссылочный***. При упаковке объекта значимого типа происходят следующие действия:

* Выделяется память в управляемой куче.
* Совершается копирование полей размерного типа в память, которая была выделена в куче.
* Возвращается адрес объекта.

Процесс извлечения адреса полей из упакованного объекта называется распаковкой (unboxing). Распаковка не является полной противоположностью упаковке. В отличие от упаковки при распаковке не происходит никакого копирования. Однако обычно вслед за распаковкой следует копирование полей, поэтому обе операции (распаковка и копирование) являются противоположностью операции упаковки.

Упаковка и распаковка/копирование снижают производительность приложения как в плане замедления, так и в расходе дополнительной памяти, поэтому нужно стараться минимизировать создание кода, в котором происходят операции упаковки и распаковки/копирования.

Когда может потребоваться использование упаковки и распаковки:

* Методы, принимающие параметры типа object: Если метод принимает параметр типа object, передача значения типа-значения приведет к упаковке.
* Полиморфизм: При использовании полиморфизма, когда метод работает с типом object, чтобы обеспечить работу с любыми типами данных
* Работа с немодифицируемыми API: Иногда приходится работать с API, которые требуют типы object, даже если у вас есть значение типа-значения.
* Интерфейсы: При передаче значений типов-значений методам, которые принимают интерфейсные типы, реализуемые этими значениями, происходит упаковка.

Предположим, у нас есть интерфейс ***IPrintable*** и структура ***Point***, ***реализующая*** этот интерфейс. Когда мы передаем экземпляр ***Point*** в ***метод***, который ***принимает параметр типа IPrintable***, происходит ***упаковка***.

**В чем различие между классом и структурой?**

Для С# классы System.Object, System.Exception, System.File-Stream и System.Random — это ссылочные типы (память выделяется из упр. кучи).
В свою очередь размерные (значимые) типы в документации называются структурами (structure) и перечислениями (enumeration). Например, структуры System.Int32, System.Boolean, System.Decimal, System.TimeSpan и перечисления System.DayOfWeek, System.10.FileAttributes и System.Drawing.FontStyle являются размерными типами (хранятся обычно в стеке потока, но могут быть встроены в ссылочные типы).

## Scope функции

**Scope (область видимости) функции** определяет контекст, в котором переменные определены и доступны для использования. Переменные, объявленные внутри функции (локальные переменные), имеют область видимости этой функции. Они существуют в стеке памяти, который является структурой данных типа LIFO (Last In, First Out).

## Когда и при каких условиях очищаются данные переменных, которые хранятся в стеке?

1. **Создание переменной**:
   - Когда функция вызывается, для неё выделяется новый фрейм в стеке, в котором хранятся все локальные переменные этой функции.
   
2. **Очистка переменных**:
   - Когда выполнение функции завершается (независимо от того, как функция была завершена: нормальный выход, исключение и т.д.), фрейм стека для этой функции удаляется.
   - Все локальные переменные, находящиеся в этом фрейме, автоматически уничтожаются и память освобождается.
 
## Что такое фрейм в стеке?

**Фрейм в стеке** (stack frame) — это область памяти, выделяемая в стеке при вызове функции. Каждый фрейм в стеке содержит:
- Локальные переменные функции
- Параметры функции
- Адрес возврата (адрес, куда программа должна вернуться после завершения функции)
- Регистр базы фрейма (или указатель стека для предыдущего фрейма)

Когда вызывается функция, создается новый фрейм в стеке, и когда функция завершается, этот фрейм удаляется.

## Как удаляется переменная из стека

Переменная, объявленная внутри функции, живет до тех пор, пока не завершится выполнение этой функции. Переменные не удаляются индивидуально из стека, вместо этого удаляется весь фрейм стека.

### Пример

```csharp
void FunctionA()
{
    int a = 10;
    FunctionB();
    int b = 20;
}

void FunctionB()
{
    int c = 30;
    // Некоторые операции
}
```

## Порядок выполнения и удаление фреймов

- Вызов FunctionA:
  - Создается фрейм в стеке для FunctionA.
  - Переменная a сохраняется в этом фрейме.

- Вызов FunctionB из FunctionA:
  - Создается новый фрейм в стеке для FunctionB.
  - Переменная c сохраняется в фрейме FunctionB.

- Завершение FunctionB:
  - Фрейм FunctionB удаляется из стека.
  - Переменная c удаляется вместе с фреймом FunctionB.

- Возвращение в FunctionA:
  - Выполняется код после вызова FunctionB.
  - Переменная b сохраняется в фрейме FunctionA.

- Завершение FunctionA:
  - Фрейм FunctionA удаляется из стека.
  - Переменные a и b удаляются вместе с фреймом FunctionA.

## Заключение

Фрейм в стеке — это блок памяти, выделяемый для выполнения функции, который содержит ***локальные переменные, параметры функции, адрес возврата и регистр базы фрейма***.
Переменные в стеке удаляются не индивидуально, а вместе с фреймом, когда функция завершается.
Удаление фрейма происходит, когда выполнение функции завершено, что освобождает всю память, занятую этим фреймом.
Таким образом, переменная из стека будет удалена только тогда, когда завершится выполнение функции, которой она принадлежит, и весь фрейм функции будет удален.

- **Название метода**: Имена методов не хранятся в стеке. Они хранятся в метаданных сборки и используются компилятором и рантаймом для различных операций, таких как вызов методов и отладка.
- **Стек**: Используется для хранения параметров функции, локальных переменных и адресов возврата при вызове функций.
- **Фреймы стека**: Создаются и удаляются по мере вызова и завершения функций.

# Хранение Value Type в стеке и в куче

**Value types** включают примитивные типы (например, `int`, `float`, `bool`), структуры (`struct`) и перечисления (`enum`). Хранение переменных типа значений зависит от контекста, в котором они объявлены:

## В стеке:

- **Локальные переменные**: Переменные типа значений, объявленные внутри функции, хранятся в стеке.
  ```csharp
  void Function()
  {
      int x = 10; // 'x' хранится в стеке
  }
  ```

- **Параметры метода**: Параметры метода, передаваемые по значению, также хранятся в стеке.
  ```csharp
  void Function(int param)
  {
      // 'param' хранится в стеке
  }
  ```

## В куче:

- **Члены класса**: Переменные типа значений, являющиеся полями класса, хранятся в куче вместе с экземпляром класса.
  ```csharp
  class MyClass
  {
      public int value; // 'value' хранится в куче вместе с экземпляром MyClass
  }
  ```

- Закрытые переменные анонимных методов и лямбд: Если переменная захвачена лямбдой или анонимным методом, она может быть перемещена в кучу.
  ```csharp
  void Function()
  {
      int captured = 10;
      Action action = () => Console.WriteLine(captured); // 'captured' может быть перемещен в кучу
  }
  ```

## Структура vs Класс: Что быстрее и когда использовать?

### Структура

* **Быстрее в некоторых случаях**: Структуры могут быть быстрее, так как они обычно хранятся в стеке, что обеспечивает быстрый доступ и автоматическое управление временем жизни.
* **Меньше накладных расходов**: Структуры не требуют аллокации в куче и сборки мусора.
* **Использование**: 
  * **Маленькие и простые объекты**: Используйте структуры для небольших и часто используемых объектов, таких как точки, комплексные числа или цветовые модели.
  * **Immutable объекты**: Структуры должны быть неизменяемыми (immutable) для избежания проблем с изменением данных.
  * **Когда наследование не нужно**: Структуры не поддерживают наследование, поэтому подходят только для простых объектов, не требующих полиморфизма.

### Класс

* **Более гибкие**: Классы поддерживают наследование, полиморфизм и интерфейсы, что делает их более гибкими для сложных объектов.
* **Управление временем жизни**: Объекты классов хранятся в куче, и их время жизни управляется сборщиком мусора, что упрощает управление памятью для длительных объектов.
* **Использование**:
  * **Сложные объекты**: Используйте классы для более сложных объектов, требующих наследования и полиморфизма.
  * **Объекты с длительным временем жизни**: Классы подходят для объектов, которые должны существовать в течение долгого времени и управляются сборщиком мусора.

---

# Делегаты, события

**Чем отличается event от delegate?**

Delegate – это по сути указатель на функцию.

В С# модель издатель — подписчик, где класс публикует событие, которое он может инициировать, и любые классы могут подписаться на это событие. Метод, вызываемый при возникновении события, определяется делегатом.

---

# Модификаторы доступа

* public: Доступен всем.
* private: Доступен только внутри своего класса.
* protected: Доступен внутри своего класса и производных классов.
* internal: Доступен только внутри текущей сборки.
* protected internal: Доступен внутри текущей сборки и производных классов.
* private protected: Доступен внутри текущего класса и производных классов в той же сборке.

---

**Что обозначает термин immutable (неизменяемый)?**

Это значит, что данные, хранящиеся в переменной, не могут быть изменены. При этом заметьте, что значение переменной может быть изменено - путём отказа от использования старых данных, которые могут быть изменены. Оригинальные данные остаются в памяти, а новые значения создаются вновь, в новой области памяти. Пример тип String.

**Какая разница между классами System.String и System.Text.StringBuilder?**

***Данные, хранящиеся в классе System.String и есть неизменяемые (immutable)***. Класс System.StringBuilder разрабатывался так, чтобы над изменяемой строкой можно было проделать множество операций. То есть при каждой операции над объектом класса System.String происходит перенос данных в новую область памяти, что влияет на производительность программы.

**Какое преимущество использования класса System.Text.StringBuilder перед System.String?**

Класс StringBuilder более эффективен в случае работы с большим количеством строк. Объекты класса System.String неизменяемы, поэтому при каждом изменении строки создаётся новый объект в памяти.

---

# Массивы

**Объясните разницу между System.Array.CopyTo() и System.Array.Clone()?**

Первая операция осуществляет глубокое копирование массива, а вторая – поверхностное. Поверхностное копирование массива копирует только сами элементы объекта класса Array, независимо от того являются они ссылочными или значимыми типами. Копирования объектов, на которые ссылаются ссылочные типы не происходит. Ссылки в новом объекте класса Array указывают на те же объекты, что и ссылки в оригинальном массиве Array. Глубокое копирование копирует как элементы класса Array, так и объекты, на которые они явно или неявно ссылаются.

---

# Приведение типов

**as, is – что это, как применяется?**

С помощью оператора ***as*** программа пытается преобразовать выражение к определенному типу, при этом не выбрасывает исключение. В случае неудачного преобразования выражение будет содержать значение null.

---

**В чем разница между throw ex; и throw;?**

***throw*** повторно выбрасывает исключение (***re-throw***), которое было обнаружено, и сохраняет трассировку стека (путь к источнику исключения).
***throw ex*** генерирует одно и то же исключение, но сбрасывает трассировку стека на метод, где делается ***throw ex***.

**Как работает return в try-catch-finally?**

Алгоритм приблизительно такой:

* Выполняется код перед оператором return;
* Выражение в return оценивается
* Выполняется finally блок
* Возвращается результат, посчитанный на шаге 2

---

# Классы

## Назовите класс .NET, от которого наследуются все классы?

System.Object.

## В каком случае вы обязаны объявить класс абстрактным?

В том случае, если класс является наследником абстрактного класса, но не все методы базового класса перекрыты и имеют реализацию.
В том случае, если хотя бы один метод класса является абстрактным

## Как работает Equals в C#?

В классе System.Object есть все несколько методов, один из них ReferenceEquals

Стоить отметить, что == и RefefenceEquals работает идентично, сравнивая ссылки на объекты в куче

```csharp
 public static bool Equals(Object objA, Object objB) 
    {
        if (objA==objB) {
            return true;
        }
        if (objA==null || objB==null) {
            return false;
        }
        return objA.Equals(objB);
    }
```

**Сравнение Value типов через Equals**

* Проверяет можно ли сделать побитовое сравнение, если да, то выполняется FastEqualsCheck(Object a, Object b);
* Если же это не побитовое сравнение, применяется рефлексия, и значения всех полей сравниваются попарно через Equals(object).

> Если структура содержит поля, которые являются ссылочными типами, следует переопределить метод Equals(Object). Это может повысить производительность и позволить более точно представить значение равенства для типа. Так как при большом количестве полей, выполнение ValueType.Equals может быть очень затратным по времени. При переопределении так же не забывайте переопределять и метод GetHashCode который используется в таких типах данных как Dictionary для сравнения объектов.

**IEqualityComparer**

Если вам нужен метод для сравнения объектов для конкретного типа, а не общей ситуации (или вы хотите сравнивать специальным образом объекты, которые вам не принадлежат), вы можете делегировать сравнение специальному объекту, реализующему интерфейс IEqualityComparer или типизированный IEqualityComparer<T>. Сравнение при помощи таких сравнивающих объектов применяют, например, Hashatable и Dictionary<K, V>, а также некоторые LINQ-методы.

К этому интерфейсу есть и его реализация с помощью EqualityComparer<T>. EqualityComparer<T>, он проверяет реализует ли объект интерфейс IEquatable<T>, и в противном случае выполняет сравнение через стандартный Equal(object). При реализации IEqualityComparer рекомендуется  наследоваться от EqualityComparer.

**IComparable**

Проверка на равенство так же может быть выполнена  через сравнение больше/меньше/равно. Для этого используются операторы сравнения </>, интерфейсы IComparable (аналог метода Equals(object)), IComparable<T> (аналог интерфейса IEquatable<T>)


## Делегаты

Делегат представляет собой объект, который может ссылаться на метод или несколько методов. Следовательно, когда создается делегат, то в итоге получается объект, содержащий ссылку на метод. Иными словами, делегат позволяет вызывать метод, на который он ссылается.

По сути, делегат — это безопасный в отношении типов объект, указывающий на другой метод (или, возможно, список методов) приложения, который может быть вызван позднее. В частности, объект делегата поддерживает три важных фрагмента информации:

адрес метода, на котором он вызывается;
аргументы (если есть) этого метода;
возвращаемое значение (если есть) этого метода.

```csharp
class TrainStation
    {
        delegate int Train();

        int Wagon1()
        {
            Console.WriteLine("wagon1 is running");
            return 1;
        }

        int Wagon2()
        {
            Console.WriteLine("wagon2 is running");
            return 2;
        }
        public void CreateTrain()
        {
            Train train = Wagon1; 
            train += Wagon2;
            train  += () => // пример с использованием лямбда выражения
            {
                Console.WriteLine("wagon3 is running");
                return 3; 
            };

            Console.WriteLine("WagonNumber:" + train());
        }
    }
    internal class Program
    {
       
        private static void Main()
        {
            var trainStation = new TrainStation();
            trainStation.CreateTrain();
            Console.ReadKey();
        }
    }
```

На экран выведется следующее:

    wagon1 is running
    wagon2 is running
    wagon3 is running
    WagonNumber:3

## В чем разница между ключевыми словами new и override при переопределении метода класса?

Модификатор override расширяет метод virtual базового класса, а модификатор new скрывает доступный метод базового класса.

# Типы данных, коллекции и структуры данных в .NET

## Dictionary

Под капотом класса Dictionary<TKey, TValue> в .NET используется структура данных, называемая хэш-таблицей. Хэш-таблица позволяет ассоциировать ключи с соответствующими значениями, обеспечивая быстрый доступ к элементам по ключу.

Основные элементы хэш-таблицы
- Массив корзин (buckets):

  > Это массив, где каждый элемент представляет собой индекс (или ссылку) на связанный список элементов (в некоторых реализациях может использоваться массив или другая структура).
  > Индекс массива определяется хэш-кодом ключа.

- Список записей (entries):

  Это массив структур, каждая из которых содержит:
  - Хэш-код ключа.
  - Ключ.
  - Значение.
  - Индекс следующей записи в случае коллизии (следующая запись в связном списке).

**Принципы работы хэш-таблицы**

- Хэширование:
  - При добавлении элемента вычисляется хэш-код ключа.
  Этот хэш-код используется для определения индекса в массиве корзин.
- Коллизии:
  - Коллизия происходит, когда два ключа имеют одинаковый хэш-код. В Dictionary<TKey, TValue> для разрешения коллизий используется метод цепочек (chaining): в каждой корзине хранится связанный список записей, которые имеют одинаковый хэш-код.
- Добавление элемента:
  - Вычисляется хэш-код ключа.
  - Определяется индекс корзины.
  - Если корзина пуста, запись добавляется напрямую.
  - Если корзина уже содержит элементы, новая запись добавляется в начало или конец связанного списка.
- Поиск элемента:
  - Вычисляется хэш-код ключа.
  - Определяется индекс корзины.
  - Проход по связанному списку записей в корзине до нахождения нужного ключа.

Dictionary использует метод GetHashCode() класса Object для вычисления целого числа которое используется для поиска индекса для вставки нового значения.

Реализовывая свой кастомный GetHashCode() вы должны удовлетворить следующие требования:

- Один и тот же объект должен всегда возвращать одинаковый хэш-код (Хэш-код не должен изменятся во время жизни объекта).
- Разные объекты могут возвращать одно и то же значение хэш-кода.
- Метод должен выполняться очень быстро.
- Он не должен генерировать эксепшенов.
- Он должен использовать как минимум одно поле экземпляра.
- Значения хэш-кода должны распределяться равномерно по всему диапазону чисел, которые может хранить int.

При удалении мы удаляем содержимое ячеек значениями по умолчанию, меняем указатели next других элементов при неоходимости и сохраняем индекс этого элемента во внутреннее поле freeList, а старое в поле next. Таким образом, при добавлении нового элемента мы можем повторно использовать такие свободные ячейки
## ListDictionary

Это простая реализация IDictionary с использованием односвязного списка. Она меньше и быстрее, чем Hashtable, если количество элементов равно 10 или меньше. Лучше не использовать этот класс, если вам важна производительность для большого количества элементов.

Принимает  в качестве параметров тип Object.

Пример инициализации:

```csharp
var dictionary = new ListDictionary
{
     { "key", "value"}
};
```

## HybridDictionary

Гибридная версия между ListDictionary и HashTable. До 10 элементов гибрит использует ListDictionary элементов если же коллекция становится больше чем 10 элементов, он переключается на работу с HashTable

## OrderedDictionary

Иногда бывают моменты когда вы хотите использовать ключи для поиска или foreach для итерации с помощью DictionaryEntry объектов. Элементы OrderedDictionary доступны с помощью ключа или индекса .Элементы OrderedDictionary не сортируются по ключу, в отличие от элементов SortedDictionary<TKey,TValue> класса который мы рассматриваем выше. 

Другим преимуществом OrderedDictionary является скорость. При просмотре большой коллекции чтение OrderedDictionary с использованием первого примера, числового индекса, всегда будет быстрее, чем при использовании метода стиля словаря.

Когда вам нужна "мощь" коллекции и простой доступ к числовому индексу, OrderedDictionary является предпочтительной коллекцией.

## SortedDictionary

Класс SortedDictionary<TKey, Tvalue> представляет дерево бинарного поиска, в котором все элементы отсортированы на основе ключа. Тип ключа должен реализовать интерфейс IComparable<TKey>. Если тип ключа не сортируемый, компаратор можно также создать, реализовав IComparer<TKey> и указав его в качестве аргумента конструктора сортированного словаря.

Классы SortedDictionary<TKey, Tvalue> и SortedList<TKey, TValue> часто сравнивают друг с другом, так как они имеют схожий функционал. Но поскольку SortedList<TKey, TValue> реализован в виде списка, основанного на массиве, a SortedDictionary<TKey, Tvalue> реализован как словарь, эти классы обладают разными характеристиками:

SortedList<TKey, TValue> использует меньше памяти, чем SortedDictionary<TKey, TValue>
SortedDictionary<TKey, TValue> быстрее вставляет и удаляет элементы.

При наполнении коллекции отсортированными данными SortedList<TKey,TValue> работает быстрее, если при этом не требуется изменение размера.

## ConcurrentDictionary

Представляет потокобезопасную коллекцию пар "ключ-значение", доступ к которой могут одновременно получать несколько потоков.

Для настройки есть 2 основных параметра:
- сapacity — первоначальное кол-во элементов. По умолчанию — 31.
- concurrencyLevel – предполагаемое число потоков на запись. По умолчанию = 4

Ниже примерный алгоритм работы:

- Вычисление хеша ключа нового элемента
- Вычисление бакета bucketNo, в который будет добавлен элемент, и номера блокировки из пула
- Блокировка bucketNo через Monitor.Enter
- Запись элемента с использованием Volatile.Write
- Освобождение блокировки Monitor.Exit

## ImmutableDictionary и ReadOnlyDictionary

ReadOnlyDictionary можно инициализировать всего один раз через конструктор, После вы не сможете добавлять или удалять в него элементы. Это полезно, если вы хотите убедиться, что он не будет изменен, пока он будет отправлен через несколько уровней вашего приложения. Вы инициализируете ReadOnlyDictionary, передавая другой экземпляр слова конструктору. Это объясняет, почему ReadOnlyDictionary является изменяемым (если базовый словарь изменен). Это просто оболочка, защищенная от прямых изменений.

В ImmutableDictionary есть методы для его модификации, такие как " Add или " Remove, но они создадут новый словарь и вернут его, исходный останется без изменений и вернется копия нового неизменяемого словаря. ImmutableDictionary является потокобезопасным, потому что вы не можете изменить исходный экземпляр (ни прямо, ни косвенно). Все методы, которые "изменяют", фактически возвращают новый экземпляр.

## IEnumerable vs IQueryable

Коллекции реализуют интерфейс IEnumerable<T> явно или неявно. Так как тип Array не является Generic типом, то он наследует только IEnumerable, а не IEnumerable<T>.  

Интерфейс IEnumerable указывает, что тип реализует GetEnumerator. Благодаря чему для него доступна конструкция foreach. С IEnumerable часто используются расширения из System.Linq. Generic интерфейс используется при возвращении из запросов (например к базе данных или к другим коллекциям).

IEnumerable подходит для перебора по коллекции и отображения результатов на фронтенде. Вы не можете изменить (добавить или удалить) данные из IEnumerable. В случае запроса к базе данных на сервере запрос вернет все данные (без фильтров) как это показано в абстрактной картинке ниже.

## IQueryable

Всякий раз, когда мы сталкиваемся с большим количеством данных необходимо подумать, какую коллекцию или какой тип использовать для работы с ними. В отличии от IEnumerable – IQueryable предлагает высокую производительность в случае работы с большим объемом данных. IQueryable предварительно фильтрует данные по запросу а затем отправляет только отфильтрованные данные клиенту.

## Разница между IQueryable и IEnumerable

Основное отличие между этими интерфейсами в том, что IEnumerable работает со всем массивом данных, а IQueryable с отфильтрованным. IEnumerable получает все данные на стороне сервера и загружает их в память а затем позволяет сделать фильтрацию по данным из памяти. Когда делается запрос к базе данных, IQueryable выполняет запрос на серверной стороне и в запросе применяет фильтрацию. 

Вот отличные картинки для сравнения этих 2х методов обращения к базе

## Когда что использовать?
**IEnumerable**

- IEnumerable может двигаться только вперед по коллекции, он не может идти назад
- Хорошо подходит для работы с данными в памяти (списки, массивы)
- Подходит для LINQ to Object и LINQ to XML
- Поддерживает отложенное выполнение (Lazy Evaluation)
- Не поддерживает произвольные запросы
- Не поддерживает ленивую загрузку (lazy loading)
- Методы расширения, работающие с IEnumerable принимают функциональные объекты

**IQueryable**

- IQueryable может двигаться только вперед по коллекции, он не может идти назад
- IQueryable лучше работает с запросами к базе данных (вне памяти)
- Подходит для LINQ to SQL
- Поддерживает отложенное выполнение (Lazy Evaluation)
- Поддерживает произвольные запросы (используя CreateQuery и метод Execute)
- Поддерживает ленивую загрузку (lazy loading)
- Методы расширения, работающие с IQueryable принимают объекты выражения (expression tree)

Основные компоненты IQueryable<T>
- Expression: Свойство типа Expression, которое хранит дерево выражений, представляющее запрос.
- Provider: Свойство типа IQueryProvider, которое отвечает за выполнение запроса, описанного в дереве выражений.

**Как LINQ-запрос преобразуется в SQL**
LINQ-запросы преобразуются в SQL благодаря деревьям выражений и провайдеру запросов. Рассмотрим, как это происходит шаг за шагом.

- Построение дерева выражений:
  - Когда вы пишете LINQ-запрос, компилятор C# создает дерево выражений, представляющее этот запрос. Это дерево выражений сохраняется в свойстве Expression объекта IQueryable<T>.
- Передача дерева выражений провайдеру:
  - Объект IQueryable<T> передает дерево выражений своему провайдеру, который реализует интерфейс IQueryProvider.
- Компиляция дерева выражений в SQL:
  - Провайдер запросов анализирует дерево выражений и генерирует соответствующий SQL-запрос. Это включает в себя преобразование методов LINQ (например, Where, Select, OrderBy) в SQL-команды.
- Выполнение SQL-запроса:
  - Провайдер запросов отправляет сгенерированный SQL-запрос на выполнение базе данных.
  - Результаты выполнения SQL-запроса возвращаются и преобразуются в объекты .NET, которые затем возвращаются как IEnumerable<T>.

## Разница между Array, List

В C# и .NET Framework Array и List являются коллекциями, которые используются для хранения множества элементов. Однако у них есть ключевые различия в функциональности, производительности и использовании.

**Array**

Основные характеристики:
- Фиксированный размер: Размер массива задается при его создании и не может быть изменен.
- Типизированный: Все элементы массива должны быть одного типа.
- Быстрый доступ: Доступ к элементам массива осуществляется за время O(1), что делает массивы очень быстрыми для доступа к элементам по индексу.
- Низкий уровень: Массивы – это более низкоуровневая структура данных, что означает меньший оверхед.

**List**

Основные характеристики:
- Динамический размер: List<T> может автоматически изменять свой размер при добавлении или удалении элементов.
- Удобные методы: List<T> предоставляет множество методов для управления коллекцией, таких как Add, Remove, Insert, Contains, Sort и т.д.
- Типизированный: List<T> является обобщенной коллекцией (generic), что позволяет использовать любой тип данных.
- Гибкость: List<T> удобен для работы с коллекциями переменной длины.
  
Под капотом класса List<T> в .NET используется массив для хранения элементов. Это позволяет List<T> обеспечивать быстрый доступ к элементам по индексу и эффективное использование памяти. Однако, так как массив имеет фиксированный размер, List<T> реализует механику изменения размера внутреннего массива для поддержки динамического добавления элементов.

Внутренние механизмы List<T>
- Внутренний массив:
    - В List<T> есть внутреннее поле, которое представляет собой массив типа T[]. Этот массив используется для хранения элементов списка.
- Изменение размера:
    - Когда вы добавляете элемент в List<T> и текущий массив не имеет достаточно места для нового элемента, List<T> создает новый массив, который обычно в два раза больше текущего.
    - Существующие элементы копируются в новый массив, после чего старый массив удаляется. Это позволяет увеличить емкость списка и минимизировать количество перераспределений памяти.
  
Основные моменты:
- Начальная емкость: начальная емкость массива установлена на 0, после при первом добавлении увеличивается до 4
- Изменение размера: Когда _size достигает текущей длины _items, создается новый массив в два раза больше, и элементы копируются в новый массив.
- Доступ по индексу: Осуществляется за время O(1) благодаря использованию массива.

## Оператор yield

В C# оператор yield используется для упрощения создания итераторов. Он позволяет определять методы, которые могут возвращать элементы последовательности по одному, вместо того чтобы сначала создавать целую коллекцию. Использование yield делает код более читаемым и менее затратным по памяти, особенно для больших коллекций.

Когда компилятор C# встречает yield return или yield break, он автоматически создает состояние машины (state machine), которая управляет процессом итерации. Это позволяет методу запомнить своё текущее состояние и продолжить выполнение с того места, где он был прерван при следующем вызове итератора.

**Преимущества использования yield**

- Простота и читабельность кода: Оператор yield позволяет писать итераторы без явного использования вспомогательных коллекций и контроля состояния.
- Экономия памяти: Не нужно заранее создавать всю коллекцию в памяти. Элементы генерируются по мере необходимости.
- Удобство обработки больших данных: С помощью yield можно обрабатывать и возвращать большие наборы данных по частям.

## LinkedList

- Двусвязный список:
  - Каждый элемент (узел) списка содержит ссылку на следующий и предыдущий элемент.
  - Это позволяет легко вставлять и удалять элементы, зная только ссылки на соседние узлы.

- Отсутствие индексов:
  - В отличие от массива или списка, LinkedList не поддерживает произвольный доступ по индексу. Элементы нужно обходить начиная с головы или хвоста.

- Эффективные операции вставки и удаления:
  - Вставка и удаление элементов в любом месте списка выполняются за время O(1), если известна позиция (ссылка на узел).
  - Операции поиска элементов требуют времени O(n), так как требуется последовательный обход списка.

```csharp
  LinkedList<int> linkedList = new LinkedList<int>();

  // Добавление элементов в начало и конец списка
  linkedList.AddLast(1);
  linkedList.AddLast(2);
  linkedList.AddFirst(0);

  // Вставка элемента после определенного узла
  LinkedListNode<int> node = linkedList.Find(1);
  linkedList.AddAfter(node, 1);

  // Удаление элемента
  linkedList.Remove(1);

  // Перебор элементов списка
  foreach (int value in linkedList)
  {
      Console.WriteLine(value);
  }
```

**Задачи, для которых может быть нужен LinkedList**

- Частые вставки и удаления элементов:
  - Если нужно часто вставлять или удалять элементы в середине коллекции, LinkedList может быть эффективнее, чем List<T>, где такие операции требуют сдвига элементов.
- Работа с коллекциями, размер которых неизвестен заранее:
  - LinkedList хорош для коллекций, размер которых изменяется во время выполнения программы.
- Сложные операции на основе указателей:
  - В некоторых алгоритмах требуется сложная манипуляция указателями на элементы, что может быть проще реализовано с использованием LinkedList.

**Заключение**

LinkedList полезен в сценариях, где необходимо часто вставлять и удалять элементы в середине списка, а также в алгоритмах, где требуется сложная манипуляция указателями. Однако, для задач, требующих быстрого произвольного доступа по индексу, List<T> или массивы могут быть предпочтительнее.

## Tree, Graph

**Для каких задач могут пригодиться графы и деревья**

Графы:
- Социальные сети: Моделирование связей между пользователями.
- Поиск путей: Алгоритмы поиска кратчайшего пути, такие как алгоритм Дейкстры или A*.
- Оптимизация сети: Задачи маршрутизации и сетевого анализа.
- Обработка естественного языка: Графы слов и синтаксические деревья.

Деревья:
- Базы данных: Индексы (например, B-деревья и B+-деревья).
- Парсинг выражений: Деревья разбора для компиляторов и интерпретаторов.
- Иерархические данные: Организационные структуры, файловые системы.
- Быстрый поиск: Двоичные деревья поиска и их вариации (AVL-деревья, красно-черные деревья).

# Потокобезопасность

## Lock

lock – это конструкция в C#, которая обеспечивает эксклюзивный доступ к определённому ресурсу, чтобы избежать состояния гонки (race conditions). Когда поток заходит в блок lock, он получает эксклюзивный доступ к объекту, переданному в lock. Другие потоки, которые пытаются войти в тот же блок lock с тем же объектом, будут заблокированы, пока первый поток не выйдет из блока lock.

```csharp
  Monitor.Enter(syncObject);
  try
  {
      // Critical section
      return dictionary[key];
  }
  finally
  {
      Monitor.Exit(syncObject);
  }
```

## Что такое object, зачем он нужен и как он используется?

object – это базовый класс всех типов в C#. Он используется в lock в качестве маркера для блокировки. Важно, чтобы этот объект был неизменяемым и общим для всех потоков, которые должны синхронизироваться между собой.

В этом примере syncObject – это объект, который используется для синхронизации доступа к ресурсу (в данном случае – к словарю dictionary).

**Зачем нужен lock?**

lock необходим для того, чтобы обеспечить безопасность потоков при доступе к общим ресурсам. Без использования lock могут возникать следующие проблемы:

- Состояние гонки (Race conditions): несколько потоков одновременно изменяют один и тот же ресурс, что приводит к некорректным результатам.
- Повреждение данных (Data corruption): данные могут быть повреждены из-за одновременного доступа к ресурсу.
- Неопределенное поведение: результат выполнения программы может быть непредсказуемым и зависеть от порядка выполнения потоков.
- Использование lock гарантирует, что только один поток в данный момент времени имеет доступ к критической секции кода, что позволяет избежать вышеуказанных проблем.

## Big O notation

https://webdevblog.ru/bolshoe-o-chto-eto-takoe-pochemu-eto-vazhno-i-pochemu-eto-ne-vazhno/

**Общие классы сложности**

- O(1): Константная сложность. Время выполнения не зависит от размера входных данных.
  
  Пример: доступ к элементу массива по индексу.
  ```csharp
  public int GetElementAtIndex(int[] array, int index)
  {
      return array[index]; // Выполняется одна операция
  }
  ```
- O(n): Линейная сложность. Время выполнения растет линейно с размером входных данных.
   
    Пример: линейный поиск в неотсортированном массиве.
    ```csharp
    public bool LinearSearch(int[] array, int target)
    {
        for (int i = 0; i < array.Length; i++)
        {
            if (array[i] == target)
            {
                return true;
            }
        }
        return false;
    }
    ```
- O(log n): Логарифмическая сложность. Время выполнения растет логарифмически с размером входных данных.
   
    Пример: бинарный поиск.
    ```csharp
    public bool BinarySearch(int[] array, int target)
    {
        int left = 0;
        int right = array.Length - 1;
        while (left <= right)
        {
            int mid = left + (right - left) / 2;
            if (array[mid] == target)
            {
                return true;
            }
            if (array[mid] < target)
            {
                left = mid + 1;
            }
            else
            {
                right = mid - 1;
            }
        }
        return false;
    }
    ```
- O(n log n): Линейно-логарифмическая сложность. Обычно встречается в алгоритмах сортировки.
  
  Пример: сортировка слиянием, быстрая сортировка в среднем случае.
  ```csharp
  public void MergeSort(int[] array)
  {
      if (array.Length <= 1) return;
      int mid = array.Length / 2;
      int[] left = array.Take(mid).ToArray();
      int[] right = array.Skip(mid).ToArray();
      MergeSort(left);
      MergeSort(right);
      Merge(array, left, right);
  }

  private void Merge(int[] array, int[] left, int[] right)
  {
      int i = 0, j = 0, k = 0;
      while (i < left.Length && j < right.Length)
      {
          if (left[i] < right[j])
          {
              array[k++] = left[i++];
          }
          else
          {
              array[k++] = right[j++];
          }
      }
      while (i < left.Length)
      {
          array[k++] = left[i++];
      }
      while (j < right.Length)
      {
          array[k++] = right[j++];
      }
  }
  ```
- O(n^2): Квадратичная сложность. Время выполнения растет пропорционально квадрату размера входных данных.
  
    Пример: сортировка пузырьком, сортировка вставками.
    ```csharp
    public void BubbleSort(int[] array)
    {
        for (int i = 0; i < array.Length - 1; i++)
        {
            for (int j = 0; j < array.Length - 1 - i; j++)
            {
                if (array[j] > array[j + 1])
                {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }
    ```
- O(2^n): Экспоненциальная сложность. Время выполнения удваивается при добавлении каждого нового элемента.
  
  Пример: решение задачи коммивояжера полным перебором.
  ```csharp
  public List<List<int>> GetPowerSet(List<int> set)
  {
      List<List<int>> powerSet = new List<List<int>>();
      int powerSetCount = (int)Math.Pow(2, set.Count);
      for (int i = 0; i < powerSetCount; i++)
      {
          List<int> subset = new List<int>();
          for (int j = 0; j < set.Count; j++)
          {
              if ((i & (1 << j)) != 0)
              {
                  subset.Add(set[j]);
              }
          }
          powerSet.Add(subset);
      }
      return powerSet;
  }
  ```
- O(n!): Факториальная сложность. Время выполнения растет факториально с увеличением размера входных данных.
  
  Пример: генерация всех перестановок строки.
  ```csharp
  public List<string> GetPermutations(string str)
  {
      List<string> permutations = new List<string>();
      Permute(str.ToCharArray(), 0, str.Length - 1, permutations);
      return permutations;
  }

  private void Permute(char[] array, int left, int right, List<string> permutations)
  {
      if (left == right)
      {
          permutations.Add(new string(array));
      }
      else
      {
          for (int i = left; i <= right; i++)
          {
              Swap(ref array[left], ref array[i]);
              Permute(array, left + 1, right, permutations);
              Swap(ref array[left], ref array[i]); // backtrack
          }
      }
  }

  private void Swap(ref char a, ref char b)
  {
      char temp = a;
      a = b;
      b = temp;
  }
  ```

# Асинхронность и параллелизм в .NET

TAP (Task-based Asynchronous Pattern) — тот самый async/await (если говорить строго, то эти слова появились уже после появления подхода и типов Task и Task<TResult>, но async/await значительно улучшил эту концепцию)

Объект задачи, также имеет определенные условия, чтобы к нему можно было применить await:

- Ожидаемый тип должен иметь публичный (или internal) метод GetAwaiter(), это может быть и метод расширения. Этот метод возвращает объект ожидания
- Объект ожидания должен реализовать интерфейс INotifyCompletion, который обязывает реализовать метод void OnCompleted(Action continuation). Также он должен иметь экземплярные свойство bool IsCompleted, метод void GetResult(). Может быть как структурой, так и классом.

## За кулисами. Машина состояний

Исходный код:

```csharp
public async Task<string> GetDataAsync()
{
    HttpClient client = new HttpClient();
    string result = await client.GetStringAsync("https://example.com");
    return result;
}
```

**Метод-заглушка** — это тот метод, который вызывается внешним кодом. Он создает и запускает машину состояний.

```csharp
public Task<string> GetDataAsync()
{
    var stateMachine = new StateMachine();
    stateMachine._builder = AsyncTaskMethodBuilder<string>.Create();
    stateMachine._state = -1;
    stateMachine._builder.Start(ref stateMachine);
    return stateMachine._builder.Task;
}

```

**Машина состояний** — управляет выполнением асинхронного метода и его состояниями. Она включает в себя переменные и логику для перехода между состояниями.

```csharp
private struct StateMachine : IAsyncStateMachine
{
    public int _state;
    public AsyncTaskMethodBuilder<string> _builder;
    private HttpClient _client;
    private TaskAwaiter<string> _awaiter;

    public void MoveNext()
    {
        string result = null;
        try
        {
            if (_state == -1)
            {
                _client = new HttpClient();
                Task<string> task = _client.GetStringAsync("https://example.com");
                _awaiter = task.GetAwaiter();
                if (!_awaiter.IsCompleted)
                {
                    _state = 0;
                    _builder.AwaitUnsafeOnCompleted(ref _awaiter, ref this);
                    return;
                }
            }
            if (_state == 0)
            {
                result = _awaiter.GetResult();
            }
        }
        catch (Exception ex)
        {
            _state = -2;
            _builder.SetException(ex);
            return;
        }

        _state = -2;
        _builder.SetResult(result);
    }

    public void SetStateMachine(IAsyncStateMachine stateMachine)
    {
        _builder.SetStateMachine(stateMachine);
    }
}
```

- Переменные: Включает переменные для хранения состояния _state, построителя задач _builder, клиента _client и ожидающего _awaiter.
- Метод MoveNext: Управляет переходами между состояниями.
  - Состояние -1: Начальное состояние. Создает HttpClient, отправляет запрос и получает TaskAwaiter.
  - Проверка завершенности: Если задача еще не завершена, сохраняет текущее состояние (_state = 0) и возвращается. Когда задача завершится, MoveNext будет вызван снова.
  - Состояние 0: Задача завершена. Получает результат из awaiter.
- Обработка исключений: Ловит исключения, возникающие во время выполнения, и передает их в AsyncTaskMethodBuilder.
- Установка результата: Когда работа завершена, устанавливает результат задачи или исключение.